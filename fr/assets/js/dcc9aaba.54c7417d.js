"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[565],{2949:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-simulation/chapter-2","title":"Chapter 9 - Gazebo for ROS 2 Integration","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-2-simulation/chapter-2.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/chapter-2","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-2-simulation/chapter-2.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Chapter 9 - Gazebo for ROS 2 Integration","sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Gazebo + Unity - Digital Twin","permalink":"/hackathon-book-robotics/fr/docs/"},"next":{"title":"Chapter 10 - Physics and Sensors in Gazebo","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/chapter-3"}}');var t=i(4848),r=i(8453);const a={title:"Chapter 9 - Gazebo for ROS 2 Integration",sidebar_position:9},s="Chapter 9: Gazebo for ROS 2 Integration",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Gazebo-ROS Bridge Architecture",id:"gazebo-ros-bridge-architecture",level:3},{value:"Communication Patterns",id:"communication-patterns",level:3},{value:"Physics and Control Integration",id:"physics-and-control-integration",level:3},{value:"Implementation",id:"implementation",level:2},{value:"URDF Model with Gazebo Extensions",id:"urdf-model-with-gazebo-extensions",level:3},{value:"Controller Configuration",id:"controller-configuration",level:3},{value:"Launch File for Gazebo Integration",id:"launch-file-for-gazebo-integration",level:3},{value:"Control Node for Humanoid Robot",id:"control-node-for-humanoid-robot",level:3},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Minimum Requirements",id:"minimum-requirements",level:3},{value:"Recommended Specifications for Humanoid Simulation",id:"recommended-specifications-for-humanoid-simulation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Initial Setup",id:"initial-setup",level:3},{value:"Basic Integration",id:"basic-integration",level:3},{value:"Advanced Integration",id:"advanced-integration",level:3},{value:"Validation Process",id:"validation-process",level:3},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Pre-deployment Validation",id:"pre-deployment-validation",level:3},{value:"Hardware Integration",id:"hardware-integration",level:3},{value:"Deployment Strategy",id:"deployment-strategy",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-9-gazebo-for-ros-2-integration",children:"Chapter 9: Gazebo for ROS 2 Integration"})}),"\n",(0,t.jsx)(e.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo integration with ROS 2 is fundamental for humanoid robotics development, providing a bridge between high-level control algorithms and realistic physics simulation. For humanoid robots, which require precise coordination of multiple joints and sensors, Gazebo enables comprehensive testing of control strategies, gait patterns, and balance algorithms in a safe environment. The integration allows developers to validate complex multi-joint controllers, sensor fusion algorithms, and whole-body behaviors before risking expensive hardware. This integration is particularly critical for humanoid robots because of their complexity and the safety requirements involved in physical testing."}),"\n",(0,t.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo-ROS 2 integration involves several key components that work together to create a comprehensive simulation environment:"}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-ros-bridge-architecture",children:"Gazebo-ROS Bridge Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The integration layer includes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo ROS packages"}),": Core packages that enable ROS 2 communication within Gazebo"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Plugin system"}),": Mechanism for extending Gazebo functionality with ROS 2 interfaces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Message passing"}),": Standardized interfaces for sensor data and actuator commands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Clock synchronization"}),": Simulation time coordination between ROS 2 nodes and Gazebo"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo-ROS 2 uses specific communication patterns:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor publishers"}),": Real-time sensor data streams (camera, IMU, joint states)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Actuator subscribers"}),": Command inputs for joint control and other actuators"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Service interfaces"}),": One-time configuration and control operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Action interfaces"}),": Long-running operations with feedback (navigation, manipulation)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"physics-and-control-integration",children:"Physics and Control Integration"}),"\n",(0,t.jsx)(e.p,{children:"The integration handles:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time control loops"}),": Maintaining specified control frequencies"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics accuracy"}),": Balancing simulation fidelity with performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor simulation"}),": Modeling sensor characteristics and noise"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-robot coordination"}),": Handling multiple robots in shared environments"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(e.p,{children:"Let's implement a complete Gazebo-ROS 2 integration for a humanoid robot:"}),"\n",(0,t.jsx)(e.h3,{id:"urdf-model-with-gazebo-extensions",children:"URDF Model with Gazebo Extensions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<robot name="humanoid_with_gazebo" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.1"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1"/>\n      <geometry>\n        <box size="0.3 0.2 0.2"/>\n      </geometry>\n      <material name="light_grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1"/>\n      <geometry>\n        <box size="0.3 0.2 0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <inertial>\n      <mass value="5.0"/>\n      <origin xyz="0 0 0.2"/>\n      <inertia ixx="0.05" ixy="0" ixz="0" iyy="0.05" iyz="0" izz="0.05"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.2"/>\n      <geometry>\n        <box size="0.2 0.15 0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.2"/>\n      <geometry>\n        <box size="0.2 0.15 0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="base_torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.2"/>\n  </joint>\n\n  \x3c!-- Head with camera --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0.05"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.05"/>\n      <geometry>\n        <sphere radius="0.08"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.05"/>\n      <geometry>\n        <sphere radius="0.08"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.4"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10.0" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Left arm --\x3e\n  <link name="left_shoulder">\n    <inertial>\n      <mass value="0.5"/>\n      <origin xyz="0 0 -0.075"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.075"/>\n      <geometry>\n        <cylinder length="0.15" radius="0.03"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.075"/>\n      <geometry>\n        <cylinder length="0.15" radius="0.03"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_shoulder"/>\n    <origin xyz="0.05 0.08 0.2"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Gazebo plugin for ROS control --\x3e\n  <gazebo>\n    <plugin name="gazebo_ros2_control" filename="libgazebo_ros2_control.so">\n      <parameters>$(find my_humanoid_description)/config/humanoid_controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Gazebo material and visual properties --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Grey</material>\n  </gazebo>\n\n  <gazebo reference="torso">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n\n  \x3c!-- Camera sensor on head --\x3e\n  <gazebo reference="head">\n    <sensor name="camera" type="camera">\n      <always_on>true</always_on>\n      <update_rate>30</update_rate>\n      <camera name="head_camera">\n        <horizontal_fov>1.047</horizontal_fov>\n        <image>\n          <width>640</width>\n          <height>480</height>\n          <format>R8G8B8</format>\n        </image>\n        <clip>\n          <near>0.1</near>\n          <far>10.0</far>\n        </clip>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <frame_name>head_camera_optical_frame</frame_name>\n        <min_depth>0.1</min_depth>\n        <max_depth>10.0</max_depth>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- IMU sensor on torso --\x3e\n  <gazebo reference="torso">\n    <sensor name="imu" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">\n        <frame_name>torso_imu_frame</frame_name>\n        <body_name>torso</body_name>\n        <topic>__default_topic__</topic>\n        <serviceName>__default_service_name__</serviceName>\n        <gaussianNoise>0.001</gaussianNoise>\n        <updateRateHZ>100.0</updateRateHZ>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# config/humanoid_controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    # Position controllers for joints\n    left_hip_position_controller:\n      type: position_controllers/JointPositionController\n\n    right_hip_position_controller:\n      type: position_controllers/JointPositionController\n\n    left_knee_position_controller:\n      type: position_controllers/JointPositionController\n\n    right_knee_position_controller:\n      type: position_controllers/JointPositionController\n\n    left_ankle_position_controller:\n      type: position_controllers/JointPositionController\n\n    right_ankle_position_controller:\n      type: position_controllers/JointPositionController\n\n# Individual joint controller parameters\nleft_hip_position_controller:\n  ros__parameters:\n    joints:\n      - left_hip_joint\n    interface_name: position\n\nright_hip_position_controller:\n  ros__parameters:\n    joints:\n      - right_hip_joint\n    interface_name: position\n\nleft_knee_position_controller:\n  ros__parameters:\n    joints:\n      - left_knee_joint\n    interface_name: position\n\nright_knee_position_controller:\n  ros__parameters:\n    joints:\n      - right_knee_joint\n    interface_name: position\n\nleft_ankle_position_controller:\n  ros__parameters:\n    joints:\n      - left_ankle_joint\n    interface_name: position\n\nright_ankle_position_controller:\n  ros__parameters:\n    joints:\n      - right_ankle_joint\n    interface_name: position\n"})}),"\n",(0,t.jsx)(e.h3,{id:"launch-file-for-gazebo-integration",children:"Launch File for Gazebo Integration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# launch/humanoid_gazebo.launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\nfrom launch.conditions import IfCondition\nfrom launch.event_handlers import OnProcessExit\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import Command, FindExecutable, LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    robot_description_path = LaunchConfiguration('robot_description_path')\n    world_path = LaunchConfiguration('world_path')\n\n    # Declare launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='true',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    declare_robot_description_path = DeclareLaunchArgument(\n        'robot_description_path',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('my_humanoid_description'),\n            'urdf',\n            'humanoid_with_gazebo.urdf.xacro'\n        ]),\n        description='Path to robot URDF file'\n    )\n\n    declare_world_path = DeclareLaunchArgument(\n        'world_path',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('my_humanoid_gazebo'),\n            'worlds',\n            'simple_room.world'\n        ]),\n        description='Path to Gazebo world file'\n    )\n\n    # Get URDF via xacro\n    robot_description_content = Command(\n        [\n            PathJoinSubstitution([FindExecutable(name='xacro')]),\n            ' ',\n            LaunchConfiguration('robot_description_path'),\n        ]\n    )\n    robot_description = {'robot_description': robot_description_content}\n\n    # Spawn robot in Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': world_path,\n            'verbose': 'false',\n        }.items()\n    )\n\n    # Robot State Publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='both',\n        parameters=[robot_description, {'use_sim_time': use_sim_time}],\n    )\n\n    # Spawn robot\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'humanoid_robot',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0',\n        ],\n        output='screen',\n    )\n\n    # Load and activate controllers\n    load_joint_state_broadcaster = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',\n             'joint_state_broadcaster'],\n        output='screen'\n    )\n\n    load_position_controllers = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start',\n             'left_hip_position_controller'],\n        output='screen'\n    )\n\n    # Create launch description\n    ld = LaunchDescription()\n\n    # Add declared launch arguments\n    ld.add_action(declare_use_sim_time)\n    ld.add_action(declare_robot_description_path)\n    ld.add_action(declare_world_path)\n\n    # Add actions\n    ld.add_action(gazebo)\n    ld.add_action(robot_state_publisher)\n    ld.add_action(spawn_entity)\n\n    # Add controller loading after spawn\n    ld.add_action(RegisterEventHandler(\n        OnProcessExit(\n            target_action=spawn_entity,\n            on_exit=[load_joint_state_broadcaster],\n        )\n    ))\n\n    ld.add_action(RegisterEventHandler(\n        OnProcessExit(\n            target_action=load_joint_state_broadcaster,\n            on_exit=[load_position_controllers],\n        )\n    ))\n\n    return ld\n"})}),"\n",(0,t.jsx)(e.h3,{id:"control-node-for-humanoid-robot",children:"Control Node for Humanoid Robot"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# scripts/humanoid_control_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport time\n\n\nclass HumanoidController(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_controller\')\n\n        # Declare parameters\n        self.declare_parameter(\'control_frequency\', 100.0)\n        self.declare_parameter(\'max_torque\', 100.0)\n        self.declare_parameter(\'joint_names\', [\n            \'left_hip_joint\', \'left_knee_joint\', \'left_ankle_joint\',\n            \'right_hip_joint\', \'right_knee_joint\', \'right_ankle_joint\'\n        ])\n\n        # Get parameters\n        self.control_frequency = self.get_parameter(\'control_frequency\').value\n        self.max_torque = self.get_parameter(\'max_torque\').value\n        self.joint_names = self.get_parameter(\'joint_names\').value\n\n        # Publishers for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n\n        # Subscribers for joint states\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(\n            1.0/self.control_frequency,\n            self.control_loop\n        )\n\n        # Internal state\n        self.current_joint_states = JointState()\n        self.balance_controller = BalanceController()\n        self.trajectory_generator = TrajectoryGenerator()\n\n        self.get_logger().info(f\'Humanoid Controller initialized with {len(self.joint_names)} joints\')\n\n    def joint_state_callback(self, msg):\n        """Update current joint states"""\n        self.current_joint_states = msg\n\n    def control_loop(self):\n        """Main control loop"""\n        # Get current joint positions\n        current_positions = self.get_current_positions()\n\n        # Generate balance control commands\n        balance_commands = self.balance_controller.compute_balance_control(\n            current_positions\n        )\n\n        # Generate trajectory commands\n        trajectory_commands = self.trajectory_generator.generate_trajectory(\n            current_positions\n        )\n\n        # Combine commands\n        final_commands = self.combine_commands(\n            balance_commands,\n            trajectory_commands\n        )\n\n        # Publish commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = final_commands\n        self.joint_cmd_pub.publish(cmd_msg)\n\n        self.get_logger().debug(f\'Published joint commands: {final_commands}\')\n\n    def get_current_positions(self):\n        """Extract current joint positions from joint state message"""\n        positions = []\n        for joint_name in self.joint_names:\n            try:\n                idx = self.current_joint_states.name.index(joint_name)\n                positions.append(self.current_joint_states.position[idx])\n            except ValueError:\n                positions.append(0.0)  # Default if joint not found\n        return positions\n\n    def combine_commands(self, balance_cmd, trajectory_cmd):\n        """Combine balance and trajectory commands"""\n        combined = []\n        for b, t in zip(balance_cmd, trajectory_cmd):\n            # Simple weighted combination (can be more sophisticated)\n            combined.append(0.7 * b + 0.3 * t)\n        return combined\n\n\nclass BalanceController:\n    """Simple balance controller for humanoid robot"""\n\n    def __init__(self):\n        self.kp = 10.0  # Proportional gain\n        self.kd = 1.0   # Derivative gain\n\n    def compute_balance_control(self, current_positions):\n        """Compute balance control commands based on current positions"""\n        commands = []\n        for pos in current_positions:\n            # Simple PD control to maintain neutral position\n            error = 0.0 - pos  # Target is 0.0 for neutral\n            command = self.kp * error  # Proportional control\n            commands.append(command)\n        return commands\n\n\nclass TrajectoryGenerator:\n    """Generate joint trajectories for humanoid movement"""\n\n    def __init__(self):\n        self.time_counter = 0.0\n        self.frequency = 0.1  # Hz for movement patterns\n\n    def generate_trajectory(self, current_positions):\n        """Generate periodic trajectory for demonstration"""\n        self.time_counter += 0.01  # Increment based on control frequency\n\n        commands = []\n        for i, pos in enumerate(current_positions):\n            # Generate different patterns for different joints\n            if i < 3:  # Left leg\n                command = 0.2 * np.sin(2 * np.pi * self.frequency * self.time_counter + i * np.pi/3)\n            else:  # Right leg\n                command = 0.2 * np.sin(2 * np.pi * self.frequency * self.time_counter + i * np.pi/3 + np.pi)\n            commands.append(command)\n\n        return commands\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = HumanoidController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info(\'Shutting down humanoid controller...\')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo-ROS 2 integration for humanoid robotics has specific hardware requirements:"}),"\n",(0,t.jsx)(e.h3,{id:"minimum-requirements",children:"Minimum Requirements"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CPU"}),": Quad-core processor (8+ cores recommended for complex humanoid models)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory"}),": 8GB RAM minimum, 16GB+ recommended for multi-joint humanoid simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"GPU"}),": OpenGL 3.3+ compatible graphics card"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Storage"}),": SSD recommended for faster asset loading"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"recommended-specifications-for-humanoid-simulation",children:"Recommended Specifications for Humanoid Simulation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CPU"}),": 12+ cores for real-time physics simulation of complex humanoid models"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory"}),": 32GB+ for detailed humanoid models with multiple DOF and sensors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"GPU"}),": NVIDIA RTX 4070 Ti or equivalent with CUDA support for advanced sensor simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"VRAM"}),": 12GB+ for detailed visual simulation (cameras, rendering)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Physics complexity scales with number of joints and contacts"}),"\n",(0,t.jsx)(e.li,{children:"Sensor simulation (especially cameras) is GPU-intensive"}),"\n",(0,t.jsx)(e.li,{children:"Real-time performance requires careful optimization of collision meshes"}),"\n",(0,t.jsx)(e.li,{children:"Multi-robot simulation increases computational requirements exponentially"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,t.jsx)(e.p,{children:"For developing Gazebo-ROS 2 integration for humanoid robotics:"}),"\n",(0,t.jsx)(e.h3,{id:"initial-setup",children:"Initial Setup"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Install Gazebo Garden/Fortress with ROS 2 Humble integration"}),"\n",(0,t.jsx)(e.li,{children:"Create URDF model with Gazebo extensions for your humanoid"}),"\n",(0,t.jsx)(e.li,{children:"Configure physics parameters for realistic humanoid simulation"}),"\n",(0,t.jsx)(e.li,{children:"Set up sensor simulation (cameras, IMUs, joint encoders)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-integration",children:"Basic Integration"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Test URDF model loading in Gazebo"}),"\n",(0,t.jsx)(e.li,{children:"Verify ROS 2 communication with joint states"}),"\n",(0,t.jsx)(e.li,{children:"Implement basic joint control"}),"\n",(0,t.jsx)(e.li,{children:"Validate sensor data output"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"advanced-integration",children:"Advanced Integration"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Add complex humanoid controllers"}),"\n",(0,t.jsx)(e.li,{children:"Implement balance and locomotion algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Add multiple sensors for perception"}),"\n",(0,t.jsx)(e.li,{children:"Test whole-body control strategies"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"validation-process",children:"Validation Process"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Compare simulation vs. real-world behavior (when available)"}),"\n",(0,t.jsx)(e.li,{children:"Adjust physics parameters for better fidelity"}),"\n",(0,t.jsx)(e.li,{children:"Validate control strategies in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Prepare for hardware deployment"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,t.jsx)(e.p,{children:"Transitioning from Gazebo simulation to real hardware:"}),"\n",(0,t.jsx)(e.h3,{id:"pre-deployment-validation",children:"Pre-deployment Validation"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Test all safety systems in simulation first"}),"\n",(0,t.jsx)(e.li,{children:"Validate emergency stop procedures in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Verify communication protocols work in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Check sensor accuracy and noise models match hardware"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"hardware-integration",children:"Hardware Integration"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Map simulation parameters to real hardware capabilities"}),"\n",(0,t.jsx)(e.li,{children:"Adjust control gains for real-world performance"}),"\n",(0,t.jsx)(e.li,{children:"Implement hardware-specific interfaces and safety systems"}),"\n",(0,t.jsx)(e.li,{children:"Validate sensor calibration against simulation models"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"deployment-strategy",children:"Deployment Strategy"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Start with simple behaviors in safe environment"}),"\n",(0,t.jsx)(e.li,{children:"Gradually increase complexity and range of motion"}),"\n",(0,t.jsx)(e.li,{children:"Monitor system performance and safety metrics"}),"\n",(0,t.jsx)(e.li,{children:"Iterate based on real-world observations"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Implement multiple safety layers in both simulation and hardware"}),"\n",(0,t.jsx)(e.li,{children:"Ensure reliable emergency stop mechanisms"}),"\n",(0,t.jsx)(e.li,{children:"Monitor for unexpected behaviors in both domains"}),"\n",(0,t.jsx)(e.li,{children:"Maintain human oversight during initial deployment"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","URDF model loads correctly in Gazebo with all Gazebo extensions"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Physics parameters are realistic for humanoid dynamics"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Joint limits and constraints are properly configured"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Sensor simulation matches real hardware characteristics"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","ROS 2 communication works for all interfaces"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Control algorithms work in simulation environment"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Collision detection works properly with humanoid morphology"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Simulation runs at real-time speed or faster with humanoid model"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Multi-joint control strategies are validated"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Emergency stop procedures are validated in simulation"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance metrics are monitored during simulation"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Simulation-to-reality transfer parameters are documented"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","All controller dependencies are properly declared"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Launch files correctly initialize the simulation environment"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. ",(0,t.jsx)(e.em,{children:"IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 2350-2354."]}),"\n",(0,t.jsxs)(e.li,{children:["Godoy, J., Mandry, N., & Remirez, A. (2018). Gazebo: A 3D multi-robot simulator. ",(0,t.jsx)(e.em,{children:"Gazebo ROS Packages Documentation"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Tedrake, R., Jackowski, Z., Miller, R., Murphey, J., & Erez, T. (2010). Using system identification to obtain reliable models for legged robots. ",(0,t.jsx)(e.em,{children:"IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 1417-1423."]}),"\n",(0,t.jsxs)(e.li,{children:["Coumans, E., & Bai, Y. (2016). Mujoco: A physics engine for model-based control. ",(0,t.jsx)(e.em,{children:"IEEE International Conference on Robotics and Automation"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Murai, R., & Kyrki, V. (2021). Simulation to reality transfer in robotics: A survey. ",(0,t.jsx)(e.em,{children:"IEEE Access"}),", 9, 142395-142418."]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>s});var o=i(6540);const t={},r=o.createContext(t);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);