"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9317],{7090:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2-simulation/chapter-7","title":"Chapter 14 - Simulation to Reality Transfer","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-2-simulation/chapter-7.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/chapter-7","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/chapter-7","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-2-simulation/chapter-7.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"title":"Chapter 14 - Simulation to Reality Transfer","sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 13 - Simulation Best Practices","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/chapter-6"},"next":{"title":"Module 2 Exercises - Simulation Environments","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/exercises/"}}');var a=t(4848),s=t(8453);const r={title:"Chapter 14 - Simulation to Reality Transfer",sidebar_position:14},o="Chapter 14: Simulation to Reality Transfer",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"The Reality Gap",id:"the-reality-gap",level:3},{value:"Domain Randomization",id:"domain-randomization",level:3},{value:"Transfer Learning Strategies",id:"transfer-learning-strategies",level:3},{value:"Uncertainty Quantification",id:"uncertainty-quantification",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Transfer Validation System",id:"transfer-validation-system",level:3},{value:"Reality Gap Mitigation System",id:"reality-gap-mitigation-system",level:3},{value:"Transfer Learning Controller",id:"transfer-learning-controller",level:3},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Transfer Validation Requirements",id:"transfer-validation-requirements",level:3},{value:"Adaptation System Requirements",id:"adaptation-system-requirements",level:3},{value:"Safety System Requirements",id:"safety-system-requirements",level:3},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Initial Setup",id:"initial-setup",level:3},{value:"Transfer Validation",id:"transfer-validation",level:3},{value:"Adaptation Implementation",id:"adaptation-implementation",level:3},{value:"Validation Process",id:"validation-process",level:3},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Pre-deployment Validation",id:"pre-deployment-validation",level:3},{value:"Progressive Deployment",id:"progressive-deployment",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Performance Validation",id:"performance-validation",level:3},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function m(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-14-simulation-to-reality-transfer",children:"Chapter 14: Simulation to Reality Transfer"})}),"\n",(0,a.jsx)(e.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,a.jsx)(e.p,{children:"Simulation to reality transfer is critical for humanoid robotics because these complex systems require extensive testing and validation in simulation before deployment on expensive hardware. Humanoid robots operate in unstructured environments with unpredictable interactions, making it essential to validate control algorithms, gait patterns, and safety systems in simulation first. The transfer process ensures that behaviors developed in simulation can be safely and effectively deployed on real hardware while accounting for the inherent differences between simulated and real environments. Success in this transfer directly impacts the safety, reliability, and performance of humanoid robots in real-world applications."}),"\n",(0,a.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,a.jsx)(e.p,{children:"Simulation to reality transfer encompasses several fundamental concepts that bridge the gap between virtual and physical systems:"}),"\n",(0,a.jsx)(e.h3,{id:"the-reality-gap",children:"The Reality Gap"}),"\n",(0,a.jsx)(e.p,{children:"The fundamental challenge in simulation-to-reality transfer:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Model Inaccuracies"}),": Differences between simulated and real physics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Noise"}),": Real sensors have different characteristics than simulated ones"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Factors"}),": Unmodeled aspects of real environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Dynamics"}),": Differences in real actuator behavior vs. simulation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,a.jsx)(e.p,{children:"Techniques to improve transfer learning:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter Variation"}),": Randomizing physics parameters during training"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Texture Randomization"}),": Varying visual textures and appearances"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lighting Variation"}),": Simulating different lighting conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Noise Injection"}),": Adding realistic noise patterns to sensor data"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"transfer-learning-strategies",children:"Transfer Learning Strategies"}),"\n",(0,a.jsx)(e.p,{children:"Methods for bridging simulation and reality:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sim-to-Real"}),": Direct transfer from simulation to reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"System Identification"}),": Calibrating simulation based on real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adaptive Control"}),": Adjusting controllers based on real-world feedback"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Progressive Transfer"}),": Gradual increase in complexity and realism"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"uncertainty-quantification",children:"Uncertainty Quantification"}),"\n",(0,a.jsx)(e.p,{children:"Managing uncertainty in transfer:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Model Confidence"}),": Assessing confidence in simulation predictions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Risk Assessment"}),": Quantifying potential failure modes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety Margins"}),": Building in safety margins for unknowns"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robust Control"}),": Designing controllers that handle uncertainty"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(e.p,{children:"Let's implement comprehensive simulation-to-reality transfer systems for humanoid robotics:"}),"\n",(0,a.jsx)(e.h3,{id:"transfer-validation-system",children:"Transfer Validation System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# transfer_validation_system.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray, String, Bool\nfrom sensor_msgs.msg import JointState, Imu, Image\nfrom geometry_msgs.msg import PoseStamped, TwistStamped\nfrom nav_msgs.msg import Odometry\nimport numpy as np\nimport time\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Tuple\nimport threading\nfrom collections import deque\nimport statistics\n\n\n@dataclass\nclass TransferMetrics:\n    """Metrics for simulation to reality transfer"""\n    position_error: float = 0.0\n    velocity_error: float = 0.0\n    orientation_error: float = 0.0\n    sensor_fidelity: float = 0.0\n    control_stability: float = 0.0\n    transfer_score: float = 0.0\n\n\nclass TransferValidationSystem(Node):\n    def __init__(self):\n        super().__init__(\'transfer_validation_system\')\n\n        # Declare parameters\n        self.declare_parameter(\'validation_frequency\', 10.0)  # Hz\n        self.declare_parameter(\'position_tolerance\', 0.05)  # meters\n        self.declare_parameter(\'orientation_tolerance\', 0.1)  # radians\n        self.declare_parameter(\'transfer_threshold\', 0.8)\n        self.declare_parameter(\'history_size\', 100)\n\n        # Get parameters\n        self.validation_frequency = self.get_parameter(\'validation_frequency\').value\n        self.position_tolerance = self.get_parameter(\'position_tolerance\').value\n        self.orientation_tolerance = self.get_parameter(\'orientation_tolerance\').value\n        self.transfer_threshold = self.get_parameter(\'transfer_threshold\').value\n        self.history_size = self.get_parameter(\'history_size\').value\n\n        # Publishers\n        self.transfer_metrics_pub = self.create_publisher(\n            Float64MultiArray,\n            \'transfer_validation/metrics\',\n            10\n        )\n\n        self.transfer_status_pub = self.create_publisher(\n            Bool,\n            \'transfer_validation/status\',\n            10\n        )\n\n        self.transfer_report_pub = self.create_publisher(\n            String,\n            \'transfer_validation/report\',\n            10\n        )\n\n        # Subscribers - for both simulation and real robot data\n        self.sim_joint_state_sub = self.create_subscription(\n            JointState,\n            \'/sim/joint_states\',\n            self.sim_joint_state_callback,\n            10\n        )\n\n        self.real_joint_state_sub = self.create_subscription(\n            JointState,\n            \'/real/joint_states\',\n            self.real_joint_state_callback,\n            10\n        )\n\n        self.sim_imu_sub = self.create_subscription(\n            Imu,\n            \'/sim/imu/data\',\n            self.sim_imu_callback,\n            10\n        )\n\n        self.real_imu_sub = self.create_subscription(\n            Imu,\n            \'/real/imu/data\',\n            self.real_imu_callback,\n            10\n        )\n\n        # Timer for transfer validation\n        self.validation_timer = self.create_timer(\n            1.0/self.validation_frequency,\n            self.transfer_validation_loop\n        )\n\n        # Internal state\n        self.sim_joint_state = None\n        self.real_joint_state = None\n        self.sim_imu = None\n        self.real_imu = None\n        self.joint_state_history = deque(maxlen=self.history_size)\n        self.imu_history = deque(maxlen=self.history_size)\n        self.current_metrics = TransferMetrics()\n        self.transfer_report = ""\n        self.validation_lock = threading.RLock()\n\n        self.get_logger().info(\'Transfer Validation System initialized\')\n\n    def sim_joint_state_callback(self, msg):\n        """Process simulation joint state data"""\n        with self.validation_lock:\n            self.sim_joint_state = msg\n\n    def real_joint_state_callback(self, msg):\n        """Process real robot joint state data"""\n        with self.validation_lock:\n            self.real_joint_state = msg\n\n    def sim_imu_callback(self, msg):\n        """Process simulation IMU data"""\n        with self.validation_lock:\n            self.sim_imu = msg\n\n    def real_imu_callback(self, msg):\n        """Process real robot IMU data"""\n        with self.validation_lock:\n            self.real_imu = msg\n\n    def transfer_validation_loop(self):\n        """Main transfer validation loop"""\n        with self.validation_lock:\n            # Calculate transfer metrics\n            self.current_metrics = self.calculate_transfer_metrics()\n\n            # Generate transfer report\n            self.transfer_report = self.generate_transfer_report()\n\n            # Publish metrics\n            metrics_msg = Float64MultiArray()\n            metrics_msg.data = [\n                self.current_metrics.position_error,\n                self.current_metrics.velocity_error,\n                self.current_metrics.orientation_error,\n                self.current_metrics.sensor_fidelity,\n                self.current_metrics.control_stability,\n                self.current_metrics.transfer_score\n            ]\n            self.transfer_metrics_pub.publish(metrics_msg)\n\n            # Publish status\n            status_msg = Bool()\n            status_msg.data = self.current_metrics.transfer_score >= self.transfer_threshold\n            self.transfer_status_pub.publish(status_msg)\n\n            # Publish report\n            report_msg = String()\n            report_msg.data = self.transfer_report\n            self.transfer_report_pub.publish(report_msg)\n\n            # Log transfer status\n            self.log_transfer_status()\n\n    def calculate_transfer_metrics(self) -> TransferMetrics:\n        """Calculate comprehensive transfer metrics"""\n        metrics = TransferMetrics()\n\n        # Check if we have both simulation and real data\n        if self.sim_joint_state is None or self.real_joint_state is None:\n            return metrics\n\n        # Calculate position error (if joint names match)\n        if (self.sim_joint_state.name == self.real_joint_state.name and\n            len(self.sim_joint_state.position) == len(self.real_joint_state.position)):\n            pos_errors = []\n            for sim_pos, real_pos in zip(self.sim_joint_state.position, self.real_joint_state.position):\n                pos_errors.append(abs(sim_pos - real_pos))\n            metrics.position_error = np.mean(pos_errors) if pos_errors else 0.0\n\n        # Calculate velocity error\n        if (len(self.sim_joint_state.velocity) == len(self.real_joint_state.velocity) and\n            len(self.sim_joint_state.velocity) > 0):\n            vel_errors = []\n            for sim_vel, real_vel in zip(self.sim_joint_state.velocity, self.real_joint_state.velocity):\n                vel_errors.append(abs(sim_vel - real_vel))\n            metrics.velocity_error = np.mean(vel_errors) if vel_errors else 0.0\n\n        # Calculate orientation error from IMU data\n        if self.sim_imu is not None and self.real_imu is not None:\n            sim_quat = np.array([self.sim_imu.orientation.x, self.sim_imu.orientation.y,\n                                self.sim_imu.orientation.z, self.sim_imu.orientation.w])\n            real_quat = np.array([self.real_imu.orientation.x, self.real_imu.orientation.y,\n                                 self.real_imu.orientation.z, self.real_imu.orientation.w])\n\n            # Calculate quaternion difference (angular error)\n            dot_product = np.dot(sim_quat, real_quat)\n            angle_error = 2 * np.arccos(abs(dot_product))\n            metrics.orientation_error = min(angle_error, np.pi)  # Clamp to pi\n\n        # Calculate sensor fidelity (based on IMU data consistency)\n        if self.sim_imu is not None and self.real_imu is not None:\n            sim_acc = np.array([self.sim_imu.linear_acceleration.x, self.sim_imu.linear_acceleration.y,\n                               self.sim_imu.linear_acceleration.z])\n            real_acc = np.array([self.real_imu.linear_acceleration.x, self.real_imu.linear_acceleration.y,\n                                self.real_imu.linear_acceleration.z])\n\n            acc_diff = np.linalg.norm(sim_acc - real_acc)\n            # Normalize based on expected acceleration range (0-20 m/s^2)\n            metrics.sensor_fidelity = max(0.0, 1.0 - acc_diff / 20.0)\n\n        # Calculate control stability (based on joint state variance)\n        if len(self.joint_state_history) > 10:\n            recent_positions = [state.position for state in list(self.joint_state_history)[-10:]]\n            if recent_positions and len(recent_positions[0]) > 0:\n                pos_array = np.array(recent_positions)\n                pos_variance = np.var(pos_array, axis=0)\n                avg_variance = np.mean(pos_variance)\n                # Convert to stability score (lower variance = higher stability)\n                metrics.control_stability = max(0.0, 1.0 - avg_variance)\n\n        # Calculate overall transfer score\n        metrics.transfer_score = np.mean([\n            max(0.0, 1.0 - metrics.position_error / self.position_tolerance),\n            max(0.0, 1.0 - metrics.orientation_error / self.orientation_tolerance),\n            metrics.sensor_fidelity,\n            metrics.control_stability\n        ])\n\n        return metrics\n\n    def generate_transfer_report(self) -> str:\n        """Generate comprehensive transfer report"""\n        report_parts = [\n            f"Transfer Validation Report - {time.strftime(\'%Y-%m-%d %H:%M:%S\')}",\n            f"Position Error: {self.current_metrics.position_error:.4f}m",\n            f"Velocity Error: {self.current_metrics.velocity_error:.4f} rad/s",\n            f"Orientation Error: {self.current_metrics.orientation_error:.4f} rad",\n            f"Sensor Fidelity: {self.current_metrics.sensor_fidelity:.3f}",\n            f"Control Stability: {self.current_metrics.control_stability:.3f}",\n            f"Transfer Score: {self.current_metrics.transfer_score:.3f}",\n            f"Status: {\'APPROVED\' if self.current_metrics.transfer_score >= self.transfer_threshold else \'REJECTED\'}"\n        ]\n\n        # Add recommendations based on metrics\n        recommendations = []\n        if self.current_metrics.position_error > self.position_tolerance:\n            recommendations.append("Position error exceeds tolerance - adjust controller parameters")\n        if self.current_metrics.orientation_error > self.orientation_tolerance:\n            recommendations.append("Orientation error exceeds tolerance - check IMU calibration")\n        if self.current_metrics.sensor_fidelity < 0.8:\n            recommendations.append("Low sensor fidelity - verify sensor models")\n\n        if recommendations:\n            report_parts.append("Recommendations:")\n            for rec in recommendations:\n                report_parts.append(f"  - {rec}")\n\n        return "\\n".join(report_parts)\n\n    def log_transfer_status(self):\n        """Log transfer validation status"""\n        if self.current_metrics.transfer_score >= self.transfer_threshold:\n            self.get_logger().info(f\'Transfer validation PASSED: {self.current_metrics.transfer_score:.3f}\')\n        else:\n            self.get_logger().warn(f\'Transfer validation FAILED: {self.current_metrics.transfer_score:.3f}\')\n\n    def get_current_transfer_metrics(self) -> TransferMetrics:\n        """Get current transfer metrics"""\n        return self.current_metrics\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    transfer_system = TransferValidationSystem()\n\n    try:\n        rclpy.spin(transfer_system)\n    except KeyboardInterrupt:\n        transfer_system.get_logger().info(\'Shutting down transfer validation system...\')\n    finally:\n        transfer_system.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(e.h3,{id:"reality-gap-mitigation-system",children:"Reality Gap Mitigation System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# reality_gap_mitigation.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray, String\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nimport numpy as np\nimport random\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Tuple\nimport threading\n\n\n@dataclass\nclass DomainRandomizationParams:\n    \"\"\"Parameters for domain randomization\"\"\"\n    physics_randomization: bool = True\n    sensor_noise_range: Tuple[float, float] = (0.001, 0.01)\n    friction_range: Tuple[float, float] = (0.5, 1.5)\n    mass_range: Tuple[float, float] = (0.8, 1.2)\n    damping_range: Tuple[float, float] = (0.8, 1.2)\n\n\nclass RealityGapMitigationSystem(Node):\n    def __init__(self):\n        super().__init__('reality_gap_mitigation_system')\n\n        # Declare parameters\n        self.declare_parameter('domain_randomization_enabled', True)\n        self.declare_parameter('randomization_frequency', 1.0)  # Hz\n        self.declare_parameter('adaptation_enabled', True)\n        self.declare_parameter('adaptation_rate', 0.01)\n\n        # Get parameters\n        self.domain_randomization_enabled = self.get_parameter('domain_randomization_enabled').value\n        self.randomization_frequency = self.get_parameter('randomization_frequency').value\n        self.adaptation_enabled = self.get_parameter('adaptation_enabled').value\n        self.adaptation_rate = self.get_parameter('adaptation_rate').value\n\n        # Publishers\n        self.randomized_params_pub = self.create_publisher(\n            Float64MultiArray,\n            'reality_gap_mitigation/randomized_params',\n            10\n        )\n\n        self.adaptation_command_pub = self.create_publisher(\n            Twist,\n            'reality_gap_mitigation/adaptation_command',\n            10\n        )\n\n        # Subscribers\n        self.sim_sensor_sub = self.create_subscription(\n            Float64MultiArray,\n            'sim/sensor_data',\n            self.sim_sensor_callback,\n            10\n        )\n\n        self.real_sensor_sub = self.create_subscription(\n            Float64MultiArray,\n            'real/sensor_data',\n            self.real_sensor_callback,\n            10\n        )\n\n        # Timer for randomization and adaptation\n        self.mitigation_timer = self.create_timer(\n            1.0/self.randomization_frequency,\n            self.mitigation_loop\n        )\n\n        # Internal state\n        self.domain_params = DomainRandomizationParams()\n        self.current_randomization = {}\n        self.sim_sensor_data = None\n        self.real_sensor_data = None\n        self.adaptation_factors = {}\n        self.mitigation_lock = threading.RLock()\n\n        self.get_logger().info('Reality Gap Mitigation System initialized')\n\n    def sim_sensor_callback(self, msg):\n        \"\"\"Process simulation sensor data\"\"\"\n        with self.mitigation_lock:\n            self.sim_sensor_data = msg.data\n\n    def real_sensor_callback(self, msg):\n        \"\"\"Process real robot sensor data\"\"\"\n        with self.mitigation_lock:\n            self.real_sensor_data = msg.data\n\n    def mitigation_loop(self):\n        \"\"\"Main mitigation loop\"\"\"\n        with self.mitigation_lock:\n            # Apply domain randomization\n            if self.domain_randomization_enabled:\n                self.apply_domain_randomization()\n\n            # Apply adaptation\n            if self.adaptation_enabled:\n                self.apply_adaptation()\n\n    def apply_domain_randomization(self):\n        \"\"\"Apply domain randomization to simulation parameters\"\"\"\n        randomization = {}\n\n        if self.domain_params.physics_randomization:\n            # Randomize friction coefficients\n            randomization['friction'] = random.uniform(\n                self.domain_params.friction_range[0],\n                self.domain_params.friction_range[1]\n            )\n\n            # Randomize mass scaling\n            randomization['mass'] = random.uniform(\n                self.domain_params.mass_range[0],\n                self.domain_params.mass_range[1]\n            )\n\n            # Randomize damping\n            randomization['damping'] = random.uniform(\n                self.domain_params.damping_range[0],\n                self.domain_params.damping_range[1]\n            )\n\n            # Randomize sensor noise\n            randomization['sensor_noise'] = random.uniform(\n                self.domain_params.sensor_noise_range[0],\n                self.domain_params.sensor_noise_range[1]\n            )\n\n        self.current_randomization = randomization\n\n        # Publish randomized parameters\n        params_msg = Float64MultiArray()\n        params_msg.data = [\n            randomization.get('friction', 1.0),\n            randomization.get('mass', 1.0),\n            randomization.get('damping', 1.0),\n            randomization.get('sensor_noise', 0.001)\n        ]\n        self.randomized_params_pub.publish(params_msg)\n\n        self.get_logger().debug(f'Applied domain randomization: {randomization}')\n\n    def apply_adaptation(self):\n        \"\"\"Apply adaptation based on sim-to-real differences\"\"\"\n        if self.sim_sensor_data is None or self.real_sensor_data is None:\n            return\n\n        # Calculate differences between simulation and reality\n        if len(self.sim_sensor_data) > 0 and len(self.real_sensor_data) > 0:\n            # Calculate sensor difference (simplified)\n            sim_array = np.array(self.sim_sensor_data[:min(len(self.sim_sensor_data), len(self.real_sensor_data))])\n            real_array = np.array(self.real_sensor_data[:len(sim_array)])\n\n            sensor_diff = real_array - sim_array\n\n            # Update adaptation factors\n            for i, diff in enumerate(sensor_diff):\n                factor_key = f'sensor_{i}_adaptation'\n                current_factor = self.adaptation_factors.get(factor_key, 0.0)\n                new_factor = current_factor + self.adaptation_rate * diff\n                self.adaptation_factors[factor_key] = np.clip(new_factor, -0.5, 0.5)\n\n            # Apply adaptation to control commands\n            adaptation_cmd = Twist()\n            adaptation_cmd.linear.x = self.adaptation_factors.get('sensor_0_adaptation', 0.0)\n            adaptation_cmd.linear.y = self.adaptation_factors.get('sensor_1_adaptation', 0.0)\n            adaptation_cmd.linear.z = self.adaptation_factors.get('sensor_2_adaptation', 0.0)\n            adaptation_cmd.angular.x = self.adaptation_factors.get('sensor_3_adaptation', 0.0)\n            adaptation_cmd.angular.y = self.adaptation_factors.get('sensor_4_adaptation', 0.0)\n            adaptation_cmd.angular.z = self.adaptation_factors.get('sensor_5_adaptation', 0.0)\n\n            self.adaptation_command_pub.publish(adaptation_cmd)\n\n    def update_domain_parameters(self, new_params: DomainRandomizationParams):\n        \"\"\"Update domain randomization parameters\"\"\"\n        with self.mitigation_lock:\n            self.domain_params = new_params\n\n    def get_current_randomization(self) -> Dict:\n        \"\"\"Get current randomization values\"\"\"\n        return self.current_randomization.copy()\n\n    def get_adaptation_factors(self) -> Dict:\n        \"\"\"Get current adaptation factors\"\"\"\n        return self.adaptation_factors.copy()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    mitigation_system = RealityGapMitigationSystem()\n\n    try:\n        rclpy.spin(mitigation_system)\n    except KeyboardInterrupt:\n        mitigation_system.get_logger().info('Shutting down reality gap mitigation system...')\n    finally:\n        mitigation_system.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h3,{id:"transfer-learning-controller",children:"Transfer Learning Controller"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# transfer_learning_controller.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray, Bool\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport threading\nfrom collections import deque\n\n\n@dataclass\nclass TransferLearningParams:\n    \"\"\"Parameters for transfer learning\"\"\"\n    sim_learning_rate: float = 0.01\n    real_adaptation_rate: float = 0.005\n    transfer_momentum: float = 0.9\n    safety_margin: float = 0.1\n    confidence_threshold: float = 0.8\n\n\nclass TransferLearningController(Node):\n    def __init__(self):\n        super().__init__('transfer_learning_controller')\n\n        # Declare parameters\n        self.declare_parameter('control_frequency', 100.0)  # Hz\n        self.declare_parameter('learning_enabled', True)\n        self.declare_parameter('safety_enabled', True)\n        self.declare_parameter('confidence_window_size', 50)\n\n        # Get parameters\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.learning_enabled = self.get_parameter('learning_enabled').value\n        self.safety_enabled = self.get_parameter('safety_enabled').value\n        self.confidence_window_size = self.get_parameter('confidence_window_size').value\n\n        # Publishers\n        self.joint_command_pub = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory_controller/joint_trajectory',\n            10\n        )\n\n        self.safety_status_pub = self.create_publisher(\n            Bool,\n            'transfer_controller/safety_status',\n            10\n        )\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            10\n        )\n\n        self.sim_command_sub = self.create_subscription(\n            JointTrajectory,\n            '/sim/joint_commands',\n            self.sim_command_callback,\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(\n            1.0/self.control_frequency,\n            self.control_loop\n        )\n\n        # Internal state\n        self.current_joint_state = JointState()\n        self.current_imu = Imu()\n        self.sim_commands = JointTrajectory()\n        self.transfer_params = TransferLearningParams()\n        self.policy_network = {}  # Simplified policy representation\n        self.confidence_history = deque(maxlen=self.confidence_window_size)\n        self.safety_limits = {}\n        self.control_lock = threading.RLock()\n\n        # Initialize safety limits\n        self.initialize_safety_limits()\n\n        self.get_logger().info('Transfer Learning Controller initialized')\n\n    def initialize_safety_limits(self):\n        \"\"\"Initialize safety limits for humanoid joints\"\"\"\n        # Define safety limits for humanoid robot joints\n        self.safety_limits = {\n            'left_hip_joint': {'min': -1.57, 'max': 1.57, 'max_velocity': 5.0, 'max_effort': 100.0},\n            'right_hip_joint': {'min': -1.57, 'max': 1.57, 'max_velocity': 5.0, 'max_effort': 100.0},\n            'left_knee_joint': {'min': 0.0, 'max': 2.35, 'max_velocity': 5.0, 'max_effort': 100.0},\n            'right_knee_joint': {'min': 0.0, 'max': 2.35, 'max_velocity': 5.0, 'max_effort': 100.0},\n            'left_ankle_joint': {'min': -0.5, 'max': 0.5, 'max_velocity': 3.0, 'max_effort': 50.0},\n            'right_ankle_joint': {'min': -0.5, 'max': 0.5, 'max_velocity': 3.0, 'max_effort': 50.0},\n        }\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process joint state data\"\"\"\n        with self.control_lock:\n            self.current_joint_state = msg\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for balance control\"\"\"\n        with self.control_lock:\n            self.current_imu = msg\n\n    def sim_command_callback(self, msg):\n        \"\"\"Process simulation commands for transfer learning\"\"\"\n        with self.control_lock:\n            self.sim_commands = msg\n\n    def control_loop(self):\n        \"\"\"Main control loop with transfer learning\"\"\"\n        with self.control_lock:\n            # Get current state\n            current_positions = list(self.current_joint_state.position) if self.current_joint_state.position else []\n            current_velocities = list(self.current_joint_state.velocity) if self.current_joint_state.velocity else []\n\n            # Calculate control commands\n            control_commands = self.calculate_control_commands(\n                current_positions,\n                current_velocities\n            )\n\n            # Apply safety checks\n            if self.safety_enabled:\n                control_commands = self.apply_safety_limits(control_commands)\n\n            # Calculate confidence in transfer\n            confidence = self.calculate_transfer_confidence()\n            self.confidence_history.append(confidence)\n\n            # Publish safety status\n            safety_msg = Bool()\n            safety_msg.data = confidence >= self.transfer_params.confidence_threshold\n            self.safety_status_pub.publish(safety_msg)\n\n            # Publish joint commands if safety checks pass\n            if confidence >= self.transfer_params.confidence_threshold:\n                trajectory_msg = self.create_joint_trajectory(control_commands)\n                self.joint_command_pub.publish(trajectory_msg)\n            else:\n                # Emergency stop if confidence is too low\n                self.emergency_stop()\n                self.get_logger().warn(f'Transfer confidence too low: {confidence:.3f}, engaging safety')\n\n    def calculate_control_commands(self, current_positions: List[float], current_velocities: List[float]) -> List[float]:\n        \"\"\"Calculate control commands using transfer learning approach\"\"\"\n        if not current_positions:\n            return [0.0] * 6  # Default for 6 joints\n\n        commands = []\n\n        # If we have simulation commands to transfer, adapt them to reality\n        if self.sim_commands.points:\n            sim_point = self.sim_commands.points[0] if self.sim_commands.points else None\n            if sim_point and len(sim_point.positions) == len(current_positions):\n                # Apply transfer learning adaptation\n                for i, (sim_pos, curr_pos) in enumerate(zip(sim_point.positions, current_positions)):\n                    # Calculate adaptation based on sim-to-real differences\n                    if self.learning_enabled:\n                        # Simple adaptation: adjust based on position error\n                        pos_error = curr_pos - sim_pos\n                        adapted_command = sim_pos - self.transfer_params.real_adaptation_rate * pos_error\n                    else:\n                        adapted_command = sim_pos\n\n                    commands.append(adapted_command)\n            else:\n                # Default behavior if no sim commands available\n                commands = [0.0] * len(current_positions)\n        else:\n            # Default behavior - maintain current position\n            commands = current_positions\n\n        return commands\n\n    def apply_safety_limits(self, commands: List[float]) -> List[float]:\n        \"\"\"Apply safety limits to control commands\"\"\"\n        if not self.current_joint_state.name:\n            return commands\n\n        limited_commands = []\n        for i, (joint_name, command) in enumerate(zip(self.current_joint_state.name, commands)):\n            if joint_name in self.safety_limits:\n                limits = self.safety_limits[joint_name]\n\n                # Apply position limits\n                command = np.clip(command, limits['min'], limits['max'])\n\n                # Add safety margin\n                command = np.clip(\n                    command,\n                    limits['min'] + self.transfer_params.safety_margin,\n                    limits['max'] - self.transfer_params.safety_margin\n                )\n\n            limited_commands.append(command)\n\n        return limited_commands\n\n    def calculate_transfer_confidence(self) -> float:\n        \"\"\"Calculate confidence in simulation to reality transfer\"\"\"\n        if not self.current_joint_state.position or not self.current_joint_state.velocity:\n            return 0.0\n\n        # Calculate confidence based on multiple factors\n        factors = []\n\n        # Factor 1: IMU-based stability (balance confidence)\n        imu_roll, imu_pitch = self.get_imu_angles()\n        balance_confidence = max(0.0, 1.0 - (abs(imu_roll) + abs(imu_pitch)))  # Normalize to [0,1]\n        factors.append(balance_confidence)\n\n        # Factor 2: Joint position consistency\n        if len(self.current_joint_state.position) > 0:\n            pos_variance = np.var(self.current_joint_state.position)\n            # Lower variance indicates more predictable behavior\n            position_confidence = max(0.0, 1.0 - min(1.0, pos_variance))\n            factors.append(position_confidence)\n\n        # Factor 3: Velocity bounds\n        if self.current_joint_state.velocity:\n            max_velocity = max(abs(v) for v in self.current_joint_state.velocity)\n            velocity_confidence = max(0.0, 1.0 - min(1.0, max_velocity / 10.0))  # Normalize against 10 rad/s\n            factors.append(velocity_confidence)\n\n        # Calculate overall confidence\n        confidence = np.mean(factors) if factors else 0.5\n        return min(1.0, max(0.0, confidence))\n\n    def get_imu_angles(self) -> Tuple[float, float]:\n        \"\"\"Extract roll and pitch angles from IMU data\"\"\"\n        quat = self.current_imu.orientation\n        # Convert quaternion to roll/pitch angles\n        sinr_cosp = 2 * (quat.w * quat.x + quat.y * quat.z)\n        cosr_cosp = 1 - 2 * (quat.x * quat.x + quat.y * quat.y)\n        roll = np.arctan2(sinr_cosp, cosr_cosp)\n\n        sinp = 2 * (quat.w * quat.y - quat.z * quat.x)\n        pitch = np.arcsin(sinp) if abs(sinp) <= 1 else np.sign(sinp) * np.pi/2\n\n        return float(roll), float(pitch)\n\n    def create_joint_trajectory(self, positions: List[float]) -> JointTrajectory:\n        \"\"\"Create joint trajectory message from positions\"\"\"\n        trajectory = JointTrajectory()\n        trajectory.joint_names = self.current_joint_state.name[:len(positions)]\n\n        point = JointTrajectoryPoint()\n        point.positions = positions\n        point.velocities = [0.0] * len(positions)  # Default to zero velocity\n        point.accelerations = [0.0] * len(positions)  # Default to zero acceleration\n        point.time_from_start = Duration(sec=0, nanosec=50000000)  # 50ms\n\n        trajectory.points = [point]\n        return trajectory\n\n    def emergency_stop(self):\n        \"\"\"Emergency stop function\"\"\"\n        # Publish zero commands to all joints\n        if self.current_joint_state.name:\n            zero_trajectory = JointTrajectory()\n            zero_trajectory.joint_names = self.current_joint_state.name\n\n            zero_point = JointTrajectoryPoint()\n            zero_point.positions = [0.0] * len(self.current_joint_state.name)\n            zero_point.velocities = [0.0] * len(self.current_joint_state.name)\n            zero_point.time_from_start = Duration(sec=0, nanosec=10000000)  # 10ms\n\n            zero_trajectory.points = [zero_point]\n            self.joint_command_pub.publish(zero_trajectory)\n\n    def update_transfer_parameters(self, new_params: TransferLearningParams):\n        \"\"\"Update transfer learning parameters\"\"\"\n        with self.control_lock:\n            self.transfer_params = new_params\n\n    def get_current_confidence(self) -> float:\n        \"\"\"Get current transfer confidence\"\"\"\n        if self.confidence_history:\n            return statistics.mean(self.confidence_history)\n        return 0.0\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = TransferLearningController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down transfer learning controller...')\n        controller.emergency_stop()\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,a.jsx)(e.p,{children:"Simulation to reality transfer for humanoid robotics has specific hardware considerations:"}),"\n",(0,a.jsx)(e.h3,{id:"transfer-validation-requirements",children:"Transfer Validation Requirements"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"High-Performance CPU"}),": For real-time comparison of sim vs. real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory"}),": Sufficient RAM for storing simulation and real-world data streams"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Network"}),": Low-latency connection for real-time data comparison"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Timing"}),": Precise synchronization between simulation and real systems"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"adaptation-system-requirements",children:"Adaptation System Requirements"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Processing Power"}),": For real-time adaptation algorithms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Storage"}),": For storing transfer models and adaptation parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensors"}),": High-fidelity sensors matching simulation models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuators"}),": Responsive actuators for quick adaptation responses"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"safety-system-requirements",children:"Safety System Requirements"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time Kernel"}),": For deterministic safety responses"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Redundant Systems"}),": Backup safety systems for critical operations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fast I/O"}),": Quick response to safety-critical situations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Monitoring"}),": Continuous monitoring of transfer metrics"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,a.jsx)(e.p,{children:"For implementing simulation to reality transfer for humanoid robotics:"}),"\n",(0,a.jsx)(e.h3,{id:"initial-setup",children:"Initial Setup"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Configure simulation with realistic physics and sensors"}),"\n",(0,a.jsx)(e.li,{children:"Set up dual data streams (simulation and real-world)"}),"\n",(0,a.jsx)(e.li,{children:"Implement basic transfer validation metrics"}),"\n",(0,a.jsx)(e.li,{children:"Establish safety monitoring systems"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"transfer-validation",children:"Transfer Validation"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement sim-to-real comparison systems"}),"\n",(0,a.jsx)(e.li,{children:"Create validation metrics for different robot aspects"}),"\n",(0,a.jsx)(e.li,{children:"Establish confidence thresholds and safety limits"}),"\n",(0,a.jsx)(e.li,{children:"Test validation systems with known behaviors"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"adaptation-implementation",children:"Adaptation Implementation"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement domain randomization techniques"}),"\n",(0,a.jsx)(e.li,{children:"Create adaptation algorithms for sim-to-real differences"}),"\n",(0,a.jsx)(e.li,{children:"Test adaptation with various scenarios"}),"\n",(0,a.jsx)(e.li,{children:"Validate safety of adapted behaviors"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"validation-process",children:"Validation Process"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Test transfer with simple behaviors first"}),"\n",(0,a.jsx)(e.li,{children:"Gradually increase complexity with validation"}),"\n",(0,a.jsx)(e.li,{children:"Verify safety systems work during transfer"}),"\n",(0,a.jsx)(e.li,{children:"Document transfer limitations and requirements"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,a.jsx)(e.p,{children:"Transitioning from simulation to real hardware:"}),"\n",(0,a.jsx)(e.h3,{id:"pre-deployment-validation",children:"Pre-deployment Validation"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Validate transfer metrics on simple behaviors"}),"\n",(0,a.jsx)(e.li,{children:"Test safety systems in both domains"}),"\n",(0,a.jsx)(e.li,{children:"Verify sensor calibration between sim and reality"}),"\n",(0,a.jsx)(e.li,{children:"Confirm actuator response characteristics"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"progressive-deployment",children:"Progressive Deployment"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Start with basic movements in safe environment"}),"\n",(0,a.jsx)(e.li,{children:"Gradually increase complexity with validation"}),"\n",(0,a.jsx)(e.li,{children:"Monitor transfer metrics during operation"}),"\n",(0,a.jsx)(e.li,{children:"Adjust adaptation parameters as needed"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement multiple safety layers in both domains"}),"\n",(0,a.jsx)(e.li,{children:"Ensure emergency stop works during transfer"}),"\n",(0,a.jsx)(e.li,{children:"Validate failure mode handling in both systems"}),"\n",(0,a.jsx)(e.li,{children:"Maintain human oversight during initial operations"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-validation",children:"Performance Validation"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Compare performance metrics between domains"}),"\n",(0,a.jsx)(e.li,{children:"Adjust control parameters for real-world operation"}),"\n",(0,a.jsx)(e.li,{children:"Validate timing constraints and latencies"}),"\n",(0,a.jsx)(e.li,{children:"Confirm safety margins are appropriate"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Transfer validation system compares sim and real data streams"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Domain randomization techniques implemented for robust transfer"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Reality gap mitigation algorithms properly configured"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Transfer learning controller adapts to real-world differences"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Safety systems validate transfer before deployment"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Confidence metrics properly calculated and monitored"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Emergency stop procedures work during transfer"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Adaptation algorithms adjust parameters in real-time"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance metrics compared between simulation and reality"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Safety thresholds properly set for transfer operations"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","All transfer dependencies properly configured"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Validation frameworks check transfer quality"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Real-time performance requirements met during transfer"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Error handling implemented for failed transfers"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Murai, R., & Kyrki, V. (2021). Simulation to reality transfer in robotics: A survey. ",(0,a.jsx)(e.em,{children:"IEEE Access"}),", 9, 142395-142418."]}),"\n",(0,a.jsxs)(e.li,{children:["Sadeghi, F., & Levine, S. (2017). CAD2RL: Real single-image flight without a single real image. ",(0,a.jsx)(e.em,{children:"Proceedings of the International Conference on Robotics and Automation"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:["James, S., Davison, A. J., & Johns, E. (2019). Translating videos to commands: Learning multi-level correspondences for robot control. ",(0,a.jsx)(e.em,{children:"IEEE Transactions on Robotics"}),", 35(2), 308-329."]}),"\n",(0,a.jsxs)(e.li,{children:["Peng, X. B., Andry, A., Zhang, E., Abbeel, P., & Dragan, A. (2021). EMI: Episodic multi-agent imitation learning for human-robot collaboration. ",(0,a.jsx)(e.em,{children:"IEEE Transactions on Robotics"}),", 37(5), 1460-1475."]}),"\n",(0,a.jsxs)(e.li,{children:["Xie, W., Tan, J., & Turk, G. (2020). Learning dexterous manipulation from random grasps. ",(0,a.jsx)(e.em,{children:"IEEE Robotics and Automation Letters"}),", 5(2), 2810-2817."]}),"\n",(0,a.jsxs)(e.li,{children:["Open Robotics. (2022). Simulation to reality transfer: Best practices and guidelines. ",(0,a.jsx)(e.em,{children:"ROS 2 Documentation"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:["Tan, J., Zhang, T., Coumans, E., Yahya, A., Guo, Y., Lee, H. S., & Caldwell, S. (2018). Sim-to-real: Learning agile locomotion skills by simulating the real world. ",(0,a.jsx)(e.em,{children:"Proceedings of the International Conference on Robotics and Automation"}),", 1-8."]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);