"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7089],{8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},9075:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-simulation/chapter-1","title":"Chapter 8 - Introduction to Simulation Environments","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-2-simulation/chapter-1.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/chapter-1","permalink":"/hackathon-book-robotics/fr/docs/module-2-simulation/chapter-1","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-2-simulation/chapter-1.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Chapter 8 - Introduction to Simulation Environments","sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Example Code","permalink":"/hackathon-book-robotics/fr/docs/module-1-ros2/examples/"},"next":{"title":"Module 2: Gazebo + Unity - Digital Twin","permalink":"/hackathon-book-robotics/fr/docs/"}}');var o=i(4848),s=i(8453);const r={title:"Chapter 8 - Introduction to Simulation Environments",sidebar_position:8},l="Chapter 8: Introduction to Simulation Environments",a={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Physics Simulation",id:"physics-simulation",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Control System Integration",id:"control-system-integration",level:3},{value:"Fidelity vs. Performance Trade-offs",id:"fidelity-vs-performance-trade-offs",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Gazebo Launch File",id:"gazebo-launch-file",level:3},{value:"Simulation Control Node",id:"simulation-control-node",level:3},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Minimum Requirements",id:"minimum-requirements",level:3},{value:"Recommended Specifications for Humanoid Simulation",id:"recommended-specifications-for-humanoid-simulation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Initial Setup",id:"initial-setup",level:3},{value:"Basic Testing",id:"basic-testing",level:3},{value:"Advanced Simulation",id:"advanced-simulation",level:3},{value:"Validation Process",id:"validation-process",level:3},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Pre-deployment Validation",id:"pre-deployment-validation",level:3},{value:"Hardware Integration",id:"hardware-integration",level:3},{value:"Deployment Strategy",id:"deployment-strategy",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-8-introduction-to-simulation-environments",children:"Chapter 8: Introduction to Simulation Environments"})}),"\n",(0,o.jsx)(n.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,o.jsx)(n.p,{children:"Simulation environments are fundamental to humanoid robotics development, providing safe, repeatable, and cost-effective platforms for testing complex behaviors before deployment on expensive hardware. For humanoid robots, which require intricate coordination of multiple subsystems (locomotion, manipulation, perception, control), simulation allows for extensive testing of control algorithms, gait patterns, and interaction behaviors without risk of hardware damage or safety concerns. Simulation environments enable researchers and engineers to iterate rapidly on complex behaviors, validate control strategies, and debug systems before risking real-world deployment."}),"\n",(0,o.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,o.jsx)(n.p,{children:"Simulation in robotics involves creating virtual environments that accurately model the physics, sensors, and dynamics of real-world systems. For humanoid robotics, simulation serves multiple critical purposes:"}),"\n",(0,o.jsx)(n.h3,{id:"physics-simulation",children:"Physics Simulation"}),"\n",(0,o.jsx)(n.p,{children:"Modern robotics simulators use sophisticated physics engines to model:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Rigid body dynamics and collisions"}),"\n",(0,o.jsx)(n.li,{children:"Joint constraints and actuator models"}),"\n",(0,o.jsx)(n.li,{children:"Contact forces and friction"}),"\n",(0,o.jsx)(n.li,{children:"Environmental interactions"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,o.jsx)(n.p,{children:"Accurate simulation of robot sensors is crucial:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Camera sensors with realistic noise and distortion"}),"\n",(0,o.jsx)(n.li,{children:"IMU sensors with bias and drift characteristics"}),"\n",(0,o.jsx)(n.li,{children:"Force/torque sensors with realistic feedback"}),"\n",(0,o.jsx)(n.li,{children:"LiDAR and other range sensors"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"control-system-integration",children:"Control System Integration"}),"\n",(0,o.jsx)(n.p,{children:"Simulation environments must support:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Real-time control loop integration"}),"\n",(0,o.jsx)(n.li,{children:"Hardware-in-the-loop testing"}),"\n",(0,o.jsx)(n.li,{children:"Communication protocol simulation"}),"\n",(0,o.jsx)(n.li,{children:"Multi-robot coordination scenarios"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"fidelity-vs-performance-trade-offs",children:"Fidelity vs. Performance Trade-offs"}),"\n",(0,o.jsx)(n.p,{children:"Simulation design involves balancing:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Physical accuracy vs. computational performance"}),"\n",(0,o.jsx)(n.li,{children:"Sensor realism vs. simulation speed"}),"\n",(0,o.jsx)(n.li,{children:"Environmental complexity vs. stability"}),"\n",(0,o.jsx)(n.li,{children:"Model detail vs. real-time constraints"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.p,{children:"Let's implement a basic simulation environment setup for humanoid robotics using Gazebo, which is the standard simulation environment for ROS 2:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example URDF model for a simplified humanoid robot --\x3e\n<?xml version="1.0" ?>\n<robot name="simple_humanoid">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1 1 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.2"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head"/>\n    <origin xyz="0.0 0.0 0.1"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10.0" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Left leg --\x3e\n  <link name="left_hip">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.15"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="left_hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_hip"/>\n    <origin xyz="-0.05 0.0 -0.075"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"gazebo-launch-file",children:"Gazebo Launch File"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# simulation_launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    robot_name = LaunchConfiguration('robot_name')\n\n    return LaunchDescription([\n        # Declare launch arguments\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation (Gazebo) clock if true'\n        ),\n        DeclareLaunchArgument(\n            'robot_name',\n            default_value='simple_humanoid',\n            description='Name of the robot to spawn'\n        ),\n\n        # Launch Gazebo\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('gazebo_ros'),\n                    'launch',\n                    'gazebo.launch.py'\n                ])\n            ])\n        ),\n\n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            output='screen',\n            parameters=[\n                {'use_sim_time': use_sim_time},\n                {'robot_description':\n                 # This would contain the URDF content\n                 # In practice, you'd load this from a file\n                }\n            ]\n        ),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-topic', 'robot_description',\n                '-entity', robot_name,\n                '-x', '0', '-y', '0', '-z', '1.0'\n            ],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,o.jsx)(n.h3,{id:"simulation-control-node",children:"Simulation Control Node"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# simulation_control.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom builtin_interfaces.msg import Duration\nimport math\n\nclass SimulationController(Node):\n    def __init__(self):\n        super().__init__(\'simulation_controller\')\n\n        # Declare parameters\n        self.declare_parameter(\'control_frequency\', 100.0)\n        self.declare_parameter(\'simulation_speed\', 1.0)\n\n        # Get parameters\n        self.control_frequency = self.get_parameter(\'control_frequency\').value\n        self.simulation_speed = self.get_parameter(\'simulation_speed\').value\n\n        # Publishers for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n\n        # Subscribers for joint states\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(\n            1.0/self.control_frequency,\n            self.control_loop\n        )\n\n        # Internal state\n        self.current_joint_states = JointState()\n        self.trajectory_generator = TrajectoryGenerator()\n\n        self.get_logger().info(\'Simulation Controller initialized\')\n\n    def joint_state_callback(self, msg):\n        """Update current joint states"""\n        self.current_joint_states = msg\n\n    def control_loop(self):\n        """Main control loop"""\n        # Generate trajectory commands\n        commands = self.trajectory_generator.generate_trajectory(\n            self.current_joint_states\n        )\n\n        # Publish commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = commands\n        self.joint_cmd_pub.publish(cmd_msg)\n\n        self.get_logger().debug(f\'Published joint commands: {commands}\')\n\nclass TrajectoryGenerator:\n    """Generates joint trajectories for simulation"""\n\n    def __init__(self):\n        self.time_counter = 0.0\n        self.frequency = 0.5  # Hz\n\n    def generate_trajectory(self, current_states):\n        """Generate sinusoidal trajectory for demonstration"""\n        self.time_counter += 0.01  # Increment based on control frequency\n\n        # Generate simple oscillating pattern for joints\n        commands = []\n        for i in range(6):  # 6 joints example\n            command = 0.5 * math.sin(2 * math.pi * self.frequency * self.time_counter + i * math.pi/3)\n            commands.append(command)\n\n        return commands\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = SimulationController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info(\'Shutting down simulation controller...\')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,o.jsx)(n.p,{children:"Simulation environments for humanoid robotics have specific hardware requirements:"}),"\n",(0,o.jsx)(n.h3,{id:"minimum-requirements",children:"Minimum Requirements"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CPU"}),": Multi-core processor (8+ cores recommended)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Memory"}),": 16GB RAM minimum, 32GB recommended for complex scenes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GPU"}),": Modern graphics card with OpenGL 3.3+ support"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Storage"}),": SSD recommended for faster asset loading"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"recommended-specifications-for-humanoid-simulation",children:"Recommended Specifications for Humanoid Simulation"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CPU"}),": 12+ cores for real-time physics simulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Memory"}),": 32GB+ for complex humanoid models with multiple DOF"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GPU"}),": NVIDIA RTX 4070 Ti or equivalent with CUDA support"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"VRAM"}),": 12GB+ for detailed sensor simulation (cameras, LiDAR)"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Physics complexity scales with number of contacts"}),"\n",(0,o.jsx)(n.li,{children:"Sensor simulation (especially cameras) is GPU-intensive"}),"\n",(0,o.jsx)(n.li,{children:"Multi-robot simulation increases computational requirements exponentially"}),"\n",(0,o.jsx)(n.li,{children:"Real-time performance requires careful optimization of collision meshes"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,o.jsx)(n.p,{children:"For developing humanoid robotics simulation:"}),"\n",(0,o.jsx)(n.h3,{id:"initial-setup",children:"Initial Setup"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Install Gazebo Garden or Fortress (ROS 2 Humble compatible)"}),"\n",(0,o.jsx)(n.li,{children:"Set up URDF models for your humanoid robot"}),"\n",(0,o.jsx)(n.li,{children:"Configure physics parameters for realistic simulation"}),"\n",(0,o.jsx)(n.li,{children:"Set up sensor simulation (cameras, IMUs, etc.)"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"basic-testing",children:"Basic Testing"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Load your robot model in Gazebo"}),"\n",(0,o.jsx)(n.li,{children:"Test basic joint movements and physics"}),"\n",(0,o.jsx)(n.li,{children:"Validate sensor data output"}),"\n",(0,o.jsx)(n.li,{children:"Implement basic control loops"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"advanced-simulation",children:"Advanced Simulation"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Add complex environments with obstacles"}),"\n",(0,o.jsx)(n.li,{children:"Implement multi-robot scenarios"}),"\n",(0,o.jsx)(n.li,{children:"Add dynamic objects and interactions"}),"\n",(0,o.jsx)(n.li,{children:"Test control algorithms under various conditions"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"validation-process",children:"Validation Process"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Compare simulation vs. real-world behavior"}),"\n",(0,o.jsx)(n.li,{children:"Adjust physics parameters for better fidelity"}),"\n",(0,o.jsx)(n.li,{children:"Validate control strategies in simulation"}),"\n",(0,o.jsx)(n.li,{children:"Prepare for hardware deployment"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,o.jsx)(n.p,{children:"Transitioning from simulation to real hardware:"}),"\n",(0,o.jsx)(n.h3,{id:"pre-deployment-validation",children:"Pre-deployment Validation"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Test all safety systems in simulation first"}),"\n",(0,o.jsx)(n.li,{children:"Validate emergency stop procedures"}),"\n",(0,o.jsx)(n.li,{children:"Verify communication protocols"}),"\n",(0,o.jsx)(n.li,{children:"Check sensor accuracy and noise models"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"hardware-integration",children:"Hardware Integration"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Map simulation parameters to real hardware"}),"\n",(0,o.jsx)(n.li,{children:"Adjust control gains for real-world performance"}),"\n",(0,o.jsx)(n.li,{children:"Implement hardware-specific interfaces"}),"\n",(0,o.jsx)(n.li,{children:"Validate sensor calibration"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"deployment-strategy",children:"Deployment Strategy"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Start with simple behaviors in safe environment"}),"\n",(0,o.jsx)(n.li,{children:"Gradually increase complexity and range of motion"}),"\n",(0,o.jsx)(n.li,{children:"Monitor system performance and safety metrics"}),"\n",(0,o.jsx)(n.li,{children:"Iterate based on real-world observations"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Implement multiple safety layers"}),"\n",(0,o.jsx)(n.li,{children:"Ensure reliable emergency stop mechanisms"}),"\n",(0,o.jsx)(n.li,{children:"Monitor for unexpected behaviors"}),"\n",(0,o.jsx)(n.li,{children:"Maintain human oversight during initial deployment"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,o.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","URDF model loads correctly in Gazebo"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Physics parameters are realistic for humanoid"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Joint limits and constraints are properly configured"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Sensor simulation matches real hardware characteristics"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Control algorithms work in simulation environment"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Collision detection works properly"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Simulation runs at real-time speed or faster"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Multi-robot scenarios are tested"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Emergency stop procedures are validated"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Performance metrics are monitored"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Simulation-to-reality transfer is validated"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All dependencies are properly declared"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. ",(0,o.jsx)(n.em,{children:"IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 2350-2354."]}),"\n",(0,o.jsxs)(n.li,{children:["Tedrake, R., Jackowski, Z., Miller, R., Murphey, J., & Erez, T. (2010). Using system identification to obtain reliable models for legged robots. ",(0,o.jsx)(n.em,{children:"IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 1417-1423."]}),"\n",(0,o.jsxs)(n.li,{children:["Coumans, E., & Bai, Y. (2016). Mujoco: A physics engine for model-based control. ",(0,o.jsx)(n.em,{children:"IEEE International Conference on Robotics and Automation"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Murai, R., & Kyrki, V. (2021). Simulation to reality transfer in robotics: A survey. ",(0,o.jsx)(n.em,{children:"IEEE Access"}),", 9, 142395-142418."]}),"\n",(0,o.jsxs)(n.li,{children:["Sadeghi, F., & Levine, S. (2017). CAD2RL: Real single-image flight without a single real image. ",(0,o.jsx)(n.em,{children:"Proceedings of the International Conference on Robotics and Automation"}),"."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);