"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9554],{8179:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-ros2/chapter-2","title":"Chapter 2: ROS 2 Nodes and Topics","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-1-ros2/chapter-2.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-2","permalink":"/hackathon-book-robotics/fr/docs/module-1-ros2/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-1-ros2/chapter-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: ROS 2 Fundamentals","permalink":"/hackathon-book-robotics/fr/docs/module-1-ros2/chapter-1"},"next":{"title":"Chapter 3: Services and Actions","permalink":"/hackathon-book-robotics/fr/docs/module-1-ros2/chapter-3"}}');var i=s(4848),o=s(8453);const r={sidebar_position:2},a="Chapter 2: ROS 2 Nodes and Topics",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-2-ros-2-nodes-and-topics",children:"Chapter 2: ROS 2 Nodes and Topics"})}),"\n",(0,i.jsx)(n.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,i.jsx)(n.p,{children:"Nodes and topics form the backbone of ROS 2 communication, enabling the distributed architecture that's essential for humanoid robotics. In humanoid robots, different components (perception, planning, control, interaction) run as separate nodes that communicate through topics. This decoupled architecture allows for modular development, fault isolation, and system scalability - all critical for complex humanoid systems that must operate reliably in human environments."}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nodes"})," are individual processes that perform computation in ROS 2. They can publish data, subscribe to data, provide services, or execute actions. Nodes are organized into packages and can be run independently, making the system modular and maintainable."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Topics"})," are named buses over which nodes exchange messages. They use a publish-subscribe communication pattern where publishers send messages to a topic and subscribers receive messages from the topic. This pattern enables:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoupling"}),": Publishers and subscribers don't need to know about each other"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability"}),": Multiple publishers and subscribers can use the same topic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexibility"}),": Nodes can be added or removed without affecting others"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The communication model is asynchronous, meaning publishers send messages without waiting for responses, and subscribers receive messages when they arrive."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Quality of Service (QoS)"})," profiles allow fine-tuning of communication behavior, including reliability, durability, and history settings, which are crucial for real-time robotic applications."]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Here's how to create a publisher node that publishes sensor data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_sensors/my_robot_sensors/joint_state_publisher.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport math\nimport random\n\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n\n        # Create publisher for joint states\n        self.publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Timer to publish at regular intervals\n        self.timer = self.create_timer(0.1, self.publish_joint_states)  # 10Hz\n\n        # Initialize joint names and positions\n        self.joint_names = ['left_hip', 'left_knee', 'left_ankle',\n                           'right_hip', 'right_knee', 'right_ankle',\n                           'left_shoulder', 'left_elbow', 'left_wrist',\n                           'right_shoulder', 'right_elbow', 'right_wrist']\n\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.time_step = 0.0\n\n    def publish_joint_states(self):\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        msg.name = self.joint_names\n        msg.position = []\n\n        # Simulate changing joint positions (in a real robot, these would come from encoders)\n        for i in range(len(self.joint_names)):\n            # Add some oscillating motion to simulate walking\n            position = math.sin(self.time_step + i * 0.5) * 0.2\n            # Add some noise to simulate real sensor readings\n            position += random.uniform(-0.01, 0.01)\n            msg.position.append(position)\n\n        self.time_step += 0.1\n        self.publisher.publish(msg)\n        self.get_logger().debug(f'Published joint states: {len(msg.position)} joints')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_state_publisher = JointStatePublisher()\n\n    try:\n        rclpy.spin(joint_state_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        joint_state_publisher.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"And here's a subscriber node that listens to the joint states:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_control/my_robot_control/joint_state_subscriber.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\n\nclass JointStateSubscriber(Node):\n    def __init__(self):\n        super().__init__('joint_state_subscriber')\n\n        # Subscribe to joint states\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n        # Publisher for computed control commands\n        self.control_publisher = self.create_publisher(\n            Float64MultiArray,\n            'control_commands',\n            10)\n\n        # Store the latest joint state\n        self.latest_joint_state = None\n        self.joint_names = []\n        self.joint_positions = []\n\n    def joint_state_callback(self, msg):\n        self.latest_joint_state = msg\n        self.joint_names = msg.name\n        self.joint_positions = list(msg.position)\n\n        # Process the joint state data\n        self.get_logger().info(f'Received {len(msg.name)} joints: {msg.name[:3]}...')\n\n        # Example: Calculate if any joint is approaching limits\n        for i, (name, pos) in enumerate(zip(msg.name, msg.position)):\n            if abs(pos) > 2.5:  # Example limit\n                self.get_logger().warn(f'Joint {name} approaching limit: {pos:.3f} rad')\n\n        # Compute and publish control commands based on current state\n        self.compute_control_commands()\n\n    def compute_control_commands(self):\n        if self.latest_joint_state is None:\n            return\n\n        # Example control logic: simple PD controller to maintain center position\n        control_commands = Float64MultiArray()\n        commands = []\n\n        for pos in self.joint_positions:\n            # Simple PD control: command = -Kp*pos - Kd*vel\n            # (In real implementation, you'd have velocity estimates)\n            command = -0.5 * pos  # Kp = 0.5, assume vel = 0 for simplicity\n            commands.append(command)\n\n        control_commands.data = commands\n        self.control_publisher.publish(control_commands)\n        self.get_logger().debug(f'Published control commands for {len(commands)} joints')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_state_subscriber = JointStateSubscriber()\n\n    try:\n        rclpy.spin(joint_state_subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        joint_state_subscriber.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,i.jsx)(n.p,{children:"When working with nodes and topics in real hardware systems:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Rate"}),": Consider the computational load of high-frequency topics (e.g., camera images at 30Hz)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Network Bandwidth"}),": For distributed systems, ensure sufficient network capacity for topic data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Usage"}),": Large message types (like PointCloud2) can consume significant memory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time Constraints"}),": Use appropriate QoS settings for time-critical topics"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots with many joints and sensors, efficient message passing is crucial for maintaining real-time performance."}),"\n",(0,i.jsx)(n.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,i.jsx)(n.p,{children:"In simulation, you can test node and topic communication patterns safely:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Start joint state publisher\nros2 run my_robot_sensors joint_state_publisher\n\n# Terminal 2: Start joint state subscriber\nros2 run my_robot_control joint_state_subscriber\n\n# Terminal 3: Monitor the topics\nros2 topic echo /joint_states\nros2 topic echo /control_commands\n\n# Terminal 4: Visualize with tools like rqt\nrqt_plot /joint_states/position[0]\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also use ROS 2 tools to inspect the system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# List all active nodes\nros2 node list\n\n# List all active topics\nros2 topic list\n\n# Show topic information\nros2 topic info /joint_states\n\n# Echo a topic with specific frequency\nros2 topic echo --field header.stamp /joint_states std_msgs/msg/Header 1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,i.jsx)(n.p,{children:"For real hardware deployment:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Drivers"}),": Ensure proper ROS 2 drivers are running for sensors/actuators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topic Mapping"}),": Map topics to actual hardware interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS Configuration"}),": Use appropriate QoS profiles for real-time requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Monitor CPU and memory usage of nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Monitoring"}),": Implement monitoring nodes for system health"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example of a hardware interface node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_hardware_interface/my_robot_hardware_interface/real_robot_interface.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom trajectory_msgs.msg import JointTrajectory\nimport threading\nimport time\n\nclass RealRobotInterface(Node):\n    def __init__(self):\n        super().__init__('real_robot_interface')\n\n        # Publishers for hardware feedback\n        self.joint_state_pub = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Subscribers for hardware commands\n        self.joint_command_sub = self.create_subscription(\n            JointTrajectory,\n            'joint_trajectory_controller/joint_trajectory',\n            self.joint_command_callback,\n            10)\n\n        # Hardware interface (in real implementation, this would connect to actual hardware)\n        self.hardware_interface = self.initialize_hardware()\n\n        # Timer for reading hardware state\n        self.state_timer = self.create_timer(0.01, self.read_hardware_state)  # 100Hz\n\n        # Lock for thread safety\n        self.hardware_lock = threading.Lock()\n\n    def initialize_hardware(self):\n        # Initialize connection to real hardware\n        # This would typically involve CAN bus, Ethernet, or serial communication\n        self.get_logger().info('Initializing hardware interface...')\n        return {'initialized': True, 'joint_count': 12}\n\n    def read_hardware_state(self):\n        # Read current state from hardware\n        with self.hardware_lock:\n            # In real implementation, read from hardware sensors\n            joint_names = ['joint_' + str(i) for i in range(12)]\n            positions = [0.0] * 12  # Read from encoders\n            velocities = [0.0] * 12  # Read from encoders\n            efforts = [0.0] * 12    # Read from torque sensors\n\n        # Publish joint state\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = joint_names\n        msg.position = positions\n        msg.velocity = velocities\n        msg.effort = efforts\n\n        self.joint_state_pub.publish(msg)\n\n    def joint_command_callback(self, msg):\n        # Send commands to hardware\n        with self.hardware_lock:\n            # In real implementation, send commands to hardware actuators\n            self.get_logger().info(f'Received trajectory command with {len(msg.points)} points')\n            # Process trajectory points and send to hardware\n\n            # For immediate position commands:\n            if len(msg.points) > 0:\n                point = msg.points[0]\n                self.send_commands_to_hardware(msg.joint_names, point.positions)\n\n    def send_commands_to_hardware(self, joint_names, positions):\n        # Send position commands to hardware\n        # This would involve actual hardware communication\n        pass\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_interface = RealRobotInterface()\n\n    try:\n        rclpy.spin(robot_interface)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_interface.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify publisher node creates and publishes messages correctly"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Confirm subscriber node receives messages from topic"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test message rate and timing requirements"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Validate data integrity between publisher and subscriber"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Check proper node cleanup and shutdown"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify QoS profile compatibility between nodes"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Woodall, W., Faust, A., Dornhege, C., Hertle, F., & Kleiner, A. (2015). Design and use paradigms for Gazebo, an open-source multi-robot simulator. ",(0,i.jsx)(n.em,{children:"2015 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)"}),", 1557-1563."]}),"\n",(0,i.jsxs)(n.li,{children:["Quigley, M., Gerkey, B., & Smart, W. D. (2009). Programming robots with ROS: a practical introduction to the robot operating system. ",(0,i.jsx)(n.em,{children:"Communications of the ACM"}),", 52(12), 69-76."]}),"\n",(0,i.jsxs)(n.li,{children:["Colom\xe9, A., & Torras, C. (2016). Joint-space control of redundant manipulators using null space projections. ",(0,i.jsx)(n.em,{children:"2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)"}),", 3251-3256."]}),"\n",(0,i.jsxs)(n.li,{children:["B\xfcrger, M., & Mayr, J. (2017). Real-time capabilities in the Robot Operating System. ",(0,i.jsx)(n.em,{children:"Robot Operating System"}),", 105-132."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);