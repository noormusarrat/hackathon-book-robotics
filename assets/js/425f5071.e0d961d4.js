"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6315],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var t=s(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},9058:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-ros2/chapter-3","title":"Chapter 3: ROS 2 Services and Actions","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-1-ros2/chapter-3.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-3","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-1-ros2/chapter-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Nodes and Topics","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-2"},"next":{"title":"Chapter 4: Humanoid Robot Control Systems","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-4"}}');var a=s(4848),o=s(8453);const r={sidebar_position:3},i="Chapter 3: ROS 2 Services and Actions",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-3-ros-2-services-and-actions",children:"Chapter 3: ROS 2 Services and Actions"})}),"\n",(0,a.jsx)(n.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,a.jsx)(n.p,{children:'Services and actions provide synchronous and asynchronous request-response communication patterns essential for humanoid robot behaviors. Services are perfect for immediate queries (like "get robot status") while actions handle long-running tasks (like "navigate to location" or "grasp object"). For humanoid robots that must interact with humans and environments, these communication patterns enable reliable, goal-oriented behaviors with proper feedback and error handling.'}),"\n",(0,a.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Services"})," implement synchronous request-response communication where a client sends a request and waits for a response. This is appropriate for quick operations that have a clear beginning and end. Services use a blocking call, so the client waits until the service completes."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Actions"})," implement asynchronous request-response communication with feedback. They're designed for long-running operations and provide:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Goal"}),": The desired outcome"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Feedback"}),": Progress updates during execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Result"}),": Final outcome when complete"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cancel"}),": Ability to interrupt ongoing operations"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Actions are ideal for behaviors that take time to complete, might fail, or need to provide progress updates - all common in humanoid robotics."}),"\n",(0,a.jsx)(n.p,{children:"The key differences:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Services"}),": Synchronous, request-response, quick operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Actions"}),": Asynchronous, with feedback, long-running operations with cancellation"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.p,{children:"Let's start with creating a service for robot status queries:"}),"\n",(0,a.jsxs)(n.p,{children:["First, create the service definition file (in a real ROS 2 package, this would be in ",(0,a.jsx)(n.code,{children:"srv/RobotStatus.srv"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"# Request (empty)\n---\n# Response\nbool is_operational\nfloat64 battery_level\nstring status_message\nint32 error_code\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here's the service server implementation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# my_robot_services/my_robot_services/robot_status_service.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import qos_profile_services_default\n\n# In a real package, you would import your custom service\n# from my_robot_interfaces.srv import RobotStatus\n# For this example, we'll use a standard service type\nfrom example_interfaces.srv import Trigger\n\n\nclass RobotStatusService(Node):\n    def __init__(self):\n        super().__init__('robot_status_service')\n\n        # Create a service server\n        self.srv = self.create_service(\n            Trigger,  # Using Trigger service for example\n            'get_robot_status',\n            self.status_callback)\n\n        self.get_logger().info('Robot status service is ready')\n\n    def status_callback(self, request, response):\n        # Simulate checking robot status\n        # In a real implementation, this would check actual robot state\n        import random\n\n        # Simulate some processing time\n        self.get_logger().info('Received status request')\n\n        # Generate simulated response\n        is_operational = True  # Could be based on actual robot state\n        battery_level = random.uniform(20.0, 100.0)\n        status_message = \"Operational\"\n        error_code = 0\n\n        # For Trigger service (which has no custom fields), we just return success\n        response.success = is_operational\n        response.message = f\"Robot operational: {status_message}, Battery: {battery_level:.1f}%\"\n\n        self.get_logger().info(f'Returning: {response.message}')\n        return response\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_status_service = RobotStatusService()\n\n    try:\n        rclpy.spin(robot_status_service)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_status_service.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, let's create an action server for a navigation task:"}),"\n",(0,a.jsxs)(n.p,{children:["First, the action definition file (in a real package, this would be in ",(0,a.jsx)(n.code,{children:"action/NavigateToPose.action"}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"# Goal\ngeometry_msgs/PoseStamped target_pose\n\n# Result\nbool success\nfloat64 distance_traveled\n\n# Feedback\nfloat64 distance_to_goal\nfloat64 remaining_time\nstring status\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here's the action server implementation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# my_robot_actions/my_robot_actions/navigate_to_pose_server.py\nimport rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom rclpy.qos import qos_profile_system_default\nfrom rclpy.duration import Duration\n\n# In a real package, you would use your custom action\n# from my_robot_interfaces.action import NavigateToPose\n# For this example, we'll use a standard action type\nfrom lifecycle_msgs.action import ChangeState\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import Header\n\n\nclass NavigateToPoseServer(Node):\n    def __init__(self):\n        super().__init__('navigate_to_pose_server')\n\n        # Create an action server\n        # Using ChangeState for example since we don't have custom action\n        self._action_server = ActionServer(\n            self,\n            ChangeState,  # Using ChangeState for example\n            'navigate_to_pose',  # In real implementation: 'navigate_to_pose'\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n\n        self.get_logger().info('Navigate to pose action server is ready')\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject a client request to begin an action.\"\"\"\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject a client request to cancel an action.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        \"\"\"Execute the goal.\"\"\"\n        self.get_logger().info('Executing goal...')\n\n        # Simulate navigation process\n        feedback_msg = ChangeState.Feedback()  # Would be NavigateToPose.Feedback\n        feedback_msg.node_name = 'navigation_simulation'  # Placeholder\n\n        for i in range(0, 100, 5):  # Simulate progress\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return ChangeState.Result()  # Would be NavigateToPose.Result\n\n            # Publish feedback\n            feedback_msg.state.label = f'Navigating: {i}%'  # Placeholder\n            goal_handle.publish_feedback(feedback_msg)\n\n            self.get_logger().info(f'Navigation progress: {i}%')\n\n            # Sleep to simulate navigation time\n            await rclpy.sleep(Duration(seconds=0.2).nanoseconds / 1e9)\n\n        goal_handle.succeed()\n\n        # Return result\n        result = ChangeState.Result()  # Would be NavigateToPose.Result\n        result.success = True  # Would be in NavigateToPose.Result\n        self.get_logger().info('Navigation completed successfully')\n\n        return result\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    navigate_to_pose_server = NavigateToPoseServer()\n\n    try:\n        rclpy.spin(navigate_to_pose_server)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        navigate_to_pose_server.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"And here's the action client implementation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# my_robot_actions/my_robot_actions/navigate_to_pose_client.py\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom rclpy.duration import Duration\n\n# Using standard action for example\nfrom lifecycle_msgs.action import ChangeState\n\n\nclass NavigateToPoseClient(Node):\n    def __init__(self):\n        super().__init__(\'navigate_to_pose_client\')\n\n        # Create an action client\n        self._action_client = ActionClient(\n            self,\n            ChangeState,  # Using ChangeState for example\n            \'navigate_to_pose\')  # In real implementation: \'navigate_to_pose\'\n\n    def send_goal(self):\n        """Send a goal to the action server."""\n        goal_msg = ChangeState.Goal()  # Would be NavigateToPose.Goal\n        goal_msg.transition.id = 1  # Placeholder\n        goal_msg.transition.label = \'navigate_to_location\'  # Placeholder\n\n        # Wait for the action server to be available\n        self.get_logger().info(\'Waiting for action server...\')\n        self._action_client.wait_for_server()\n\n        # Send the goal\n        self.get_logger().info(\'Sending navigation goal...\')\n        send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        # Add a callback for when the goal is accepted\n        send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        """Handle the response from sending the goal."""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected\')\n            return\n\n        self.get_logger().info(\'Goal accepted\')\n        # Get the result\n        get_result_future = goal_handle.get_result_async()\n        get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        """Handle the result of the action."""\n        result = future.result().result\n        self.get_logger().info(f\'Result: {result}\')\n        rclpy.shutdown()\n\n    def feedback_callback(self, feedback_msg):\n        """Handle feedback from the action."""\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f\'Received feedback: {feedback.state.label}\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = NavigateToPoseClient()\n\n    # Send the goal\n    action_client.send_goal()\n\n    try:\n        rclpy.spin(action_client)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        action_client.destroy_node()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,a.jsx)(n.p,{children:"When using services and actions in hardware systems:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Service Latency"}),": Ensure service responses meet real-time requirements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Cancellation"}),": Implement proper cancellation handling for safety"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Feedback Rate"}),": Balance feedback frequency with communication overhead"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Management"}),": Long-running actions may consume significant resources"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For humanoid robots, consider the timing requirements for human-robot interaction where delays can affect user experience."}),"\n",(0,a.jsx)(n.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,a.jsx)(n.p,{children:"Testing services and actions in simulation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Start the action server\nros2 run my_robot_actions navigate_to_pose_server\n\n# Terminal 2: Send a goal using the client\nros2 run my_robot_actions navigate_to_pose_client\n\n# You can also use command line tools\nros2 action send_goal /navigate_to_pose lifecycle_msgs/action/ChangeState \"{transition: {id: 1, label: 'navigate'}}\"\n"})}),"\n",(0,a.jsx)(n.p,{children:"For debugging, you can also check action status:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# List all action servers\nros2 action list\n\n# Show action types\nros2 action types\n\n# Get information about a specific action\nros2 action info /navigate_to_pose\n"})}),"\n",(0,a.jsx)(n.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,a.jsx)(n.p,{children:"For real hardware deployment:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Service Reliability"}),": Ensure services are available when needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Monitoring"}),": Monitor long-running actions for timeouts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safety Integration"}),": Integrate service/action calls with safety systems"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling"}),": Implement comprehensive error handling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Graceful Degradation"}),": Handle service/action failures gracefully"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example of a real-world service call with safety integration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# my_robot_safety/my_robot_safety/safe_command_service.py\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom rclpy.qos import qos_profile_services_default\nfrom example_interfaces.srv import Trigger  # Using for example\nfrom std_msgs.msg import Bool\n\n\nclass SafeCommandService(Node):\n    def __init__(self):\n        super().__init__(\'safe_command_service\')\n\n        # Service for requesting safe commands\n        self.srv = self.create_service(\n            Trigger,  # Would use custom service in real implementation\n            \'safe_command\',\n            self.safe_command_callback)\n\n        # Publisher for safety status\n        self.safety_pub = self.create_publisher(Bool, \'safety_status\', 10)\n\n        # Subscribe to safety system\n        self.safety_sub = self.create_subscription(\n            Bool,\n            \'safety_enabled\',\n            self.safety_callback,\n            10)\n\n        self.safety_enabled = True\n\n    def safety_callback(self, msg):\n        self.safety_enabled = msg.data\n\n    def safe_command_callback(self, request, response):\n        # Check safety status before executing command\n        if not self.safety_enabled:\n            response.success = False\n            response.message = "Safety system disabled - command rejected"\n            self.get_logger().warn("Command rejected due to safety")\n            return response\n\n        # Execute safe command\n        try:\n            # Perform the actual command (e.g., move to safe position)\n            self.execute_safe_command()\n            response.success = True\n            response.message = "Safe command executed successfully"\n        except Exception as e:\n            response.success = False\n            response.message = f"Command failed: {str(e)}"\n            self.get_logger().error(f"Safe command failed: {str(e)}")\n\n        # Publish updated safety status\n        safety_msg = Bool()\n        safety_msg.data = self.safety_enabled\n        self.safety_pub.publish(safety_msg)\n\n        return response\n\n    def execute_safe_command(self):\n        # Implementation of the safe command\n        # This might involve moving to a safe position, stopping motors, etc.\n        self.get_logger().info("Executing safe command")\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safe_command_service = SafeCommandService()\n\n    try:\n        rclpy.spin(safe_command_service)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        safe_command_service.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify service server creates and responds to requests"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Confirm service client can send requests and receive responses"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test action server accepts goals and provides feedback"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Validate action client can send goals and receive results"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Check proper cancellation handling for actions"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify error handling in both services and actions"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Woodall, W., Dornhege, C., Hertle, F., & Kleiner, A. (2015). The Robot Operating System 2: Design, architecture, and uses in the wild. ",(0,a.jsx)(n.em,{children:"arXiv preprint arXiv:2008.08387"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Quigley, M., Gerkey, B., & Smart, W. D. (2009). Programming robots with ROS: a practical introduction to the robot operating system. ",(0,a.jsx)(n.em,{children:"O'Reilly Media"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Dornhege, C., Hertle, F., & Ferrein, A. (2013). The skill layer: A middleware for using ROS components in real-time robotic applications. ",(0,a.jsx)(n.em,{children:"Proceedings of the 1st International Workshop on Middleware and Systems"}),", 1-6."]}),"\n",(0,a.jsxs)(n.li,{children:["Macenski, S., Woodall, W., & Faust, A. (2022). ROS 2: The evolution of the Robot Operating System for real-time and safety-critical applications. ",(0,a.jsx)(n.em,{children:"IEEE Robotics & Automation Magazine"}),", 29(3), 11-21."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);