"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9575],{603:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-ros2/chapter-4","title":"Chapter 4: Humanoid Robot Control Systems","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-1-ros2/chapter-4.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-4","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-1-ros2/chapter-4.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Services and Actions","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-3"},"next":{"title":"Chapter 5: ROS 2 for Humanoid Robots","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-5"}}');var s=o(4848),r=o(8453);const i={sidebar_position:4},a="Chapter 4: Humanoid Robot Control Systems",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function m(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-4-humanoid-robot-control-systems",children:"Chapter 4: Humanoid Robot Control Systems"})}),"\n",(0,s.jsx)(e.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,s.jsx)(e.p,{children:"Control systems are the brain of humanoid robots, translating high-level goals into precise motor commands. Unlike wheeled or simple manipulator robots, humanoid robots must manage complex multi-degree-of-freedom systems while maintaining balance, avoiding falls, and executing coordinated movements. The control architecture must handle real-time constraints, safety requirements, and the intricate dynamics of bipedal locomotion, making it fundamental to successful humanoid operation."}),"\n",(0,s.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robot control systems typically follow a hierarchical architecture:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High-level Planning"}),": Generate motion plans and goals"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Trajectory Generation"}),": Create time-parameterized trajectories"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Low-level Control"}),": Execute precise motor commands"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety Systems"}),": Monitor and enforce safety constraints"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Key control concepts for humanoid robots include:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance Control"}),": Maintaining center of mass within support polygon"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Whole-Body Control"}),": Coordinated control of all degrees of freedom"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Impedance Control"}),": Controlling interaction forces with environment"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Admittance Control"}),": Controlling motion in response to external forces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Model Predictive Control"}),": Using dynamic models for future-aware control"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"The control system must also handle the unique challenges of humanoid robots:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Underactuation (fewer actuators than degrees of freedom during walking)"}),"\n",(0,s.jsx)(e.li,{children:"Complex kinematic chains with multiple closed loops"}),"\n",(0,s.jsx)(e.li,{children:"Contact transitions (foot contact, grasping)"}),"\n",(0,s.jsx)(e.li,{children:"Dynamic balance requirements"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(e.p,{children:"Let's implement a basic humanoid control system architecture using ROS 2:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# my_robot_control/my_robot_control/humanoid_controller.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import qos_profile_sensor_data\nfrom rclpy.qos import qos_profile_services_default\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Pose, Twist, WrenchStamped\nfrom std_msgs.msg import Float64MultiArray\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.msg import JointTrajectoryControllerState\nimport numpy as np\nimport math\n\n\nclass HumanoidController(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_controller\')\n\n        # Subscribers for sensor data\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            qos_profile=qos_profile_sensor_data)\n\n        self.imu_sub = self.create_subscription(\n            # In a real system, this would be sensor_msgs/Imu\n            # For this example, using Float64MultiArray to simulate IMU data\n            Float64MultiArray,\n            \'/imu_data\',\n            self.imu_callback,\n            qos_profile=qos_profile_sensor_data)\n\n        # Publishers for control commands\n        self.joint_cmd_pub = self.create_publisher(\n            JointTrajectory,\n            \'/joint_trajectory_controller/joint_trajectory\',\n            10)\n\n        self.com_pub = self.create_publisher(\n            Pose,\n            \'/center_of_mass\',\n            10)\n\n        # Service for control mode switching\n        self.control_mode_srv = self.create_service(\n            # Using standard service for example\n            # In real system, would use custom service\n            Float64MultiArray,\n            \'set_control_mode\',\n            self.control_mode_callback)\n\n        # Internal state\n        self.current_joint_positions = {}\n        self.current_joint_velocities = {}\n        self.imu_data = None\n        self.control_mode = \'idle\'  # idle, walking, standing, manipulation\n        self.balance_state = {\n            \'com_position\': np.array([0.0, 0.0, 0.0]),\n            \'com_velocity\': np.array([0.0, 0.0, 0.0]),\n            \'support_polygon\': [],\n            \'zmp\': np.array([0.0, 0.0])\n        }\n\n        # Control parameters\n        self.control_frequency = 100  # Hz\n        self.balance_margin = 0.05  # meters\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(\n            1.0 / self.control_frequency,\n            self.control_loop)\n\n        self.get_logger().info(\'Humanoid controller initialized\')\n\n    def joint_state_callback(self, msg):\n        """Process joint state messages from robot or simulation."""\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.current_joint_positions[name] = msg.position[i]\n            if i < len(msg.velocity):\n                self.current_joint_velocities[name] = msg.velocity[i]\n\n        # Update center of mass estimate\n        self.update_center_of_mass()\n\n    def imu_callback(self, msg):\n        """Process IMU data for balance control."""\n        # In a real system, this would be sensor_msgs/Imu\n        # Extract orientation, angular velocity, and linear acceleration\n        if len(msg.data) >= 9:  # Assuming [orientation, angular_vel, linear_acc]\n            self.imu_data = {\n                \'orientation\': msg.data[0:4],  # [x, y, z, w]\n                \'angular_velocity\': msg.data[4:7],  # [x, y, z]\n                \'linear_acceleration\': msg.data[7:10]  # [x, y, z]\n            }\n\n    def control_mode_callback(self, request, response):\n        """Handle control mode switching requests."""\n        if len(request.data) > 0:\n            new_mode = int(request.data[0])\n            modes = {0: \'idle\', 1: \'standing\', 2: \'walking\', 3: \'manipulation\'}\n            if new_mode in modes:\n                self.control_mode = modes[new_mode]\n                response.data = [1.0]  # Success\n                self.get_logger().info(f\'Switched to control mode: {self.control_mode}\')\n            else:\n                response.data = [0.0]  # Failure\n        else:\n            response.data = [0.0]  # Failure - no mode specified\n\n        return response\n\n    def update_center_of_mass(self):\n        """Estimate center of mass based on joint positions."""\n        # Simplified CoM calculation - in reality this would use full kinematic model\n        # This is a placeholder implementation\n        com_x = 0.0\n        com_y = 0.0\n        com_z = 0.8  # Approximate height for humanoid\n\n        # More sophisticated calculation would involve:\n        # 1. Kinematic chain traversal\n        # 2. Link mass distribution\n        # 3. Joint angles and positions\n        # 4. Inverse dynamics\n\n        self.balance_state[\'com_position\'] = np.array([com_x, com_y, com_z])\n\n        # Publish CoM for visualization\n        com_msg = Pose()\n        com_msg.position.x = com_x\n        com_msg.position.y = com_y\n        com_msg.position.z = com_z\n        self.com_pub.publish(com_msg)\n\n    def control_loop(self):\n        """Main control loop executing at control_frequency."""\n        if not self.current_joint_positions:\n            return  # Wait for initial joint state\n\n        # Execute control based on current mode\n        if self.control_mode == \'standing\':\n            self.execute_standing_control()\n        elif self.control_mode == \'walking\':\n            self.execute_walking_control()\n        elif self.control_mode == \'manipulation\':\n            self.execute_manipulation_control()\n        # Default: idle mode does nothing\n\n        # Safety checks\n        self.perform_safety_checks()\n\n    def execute_standing_control(self):\n        """Execute standing balance control."""\n        # Calculate desired joint positions to maintain balance\n        # This would typically use a balance controller like:\n        # - PID controller on CoM position\n        # - Inverted pendulum model\n        # - Capture point method\n\n        # For this example, maintain current positions with small adjustments\n        desired_positions = []\n        joint_names = []\n\n        for joint_name, current_pos in self.current_joint_positions.items():\n            # Simple PD control to maintain position\n            desired_pos = current_pos  # For standing, maintain current position\n            desired_positions.append(desired_pos)\n            joint_names.append(joint_name)\n\n        # Send trajectory command\n        self.send_joint_trajectory(joint_names, desired_positions)\n\n    def execute_walking_control(self):\n        """Execute walking gait control."""\n        # Walking control is complex and involves:\n        # 1. Gait pattern generation\n        # 2. Footstep planning\n        # 3. Balance maintenance during walking\n        # 4. Swing and stance phase management\n\n        # This is a simplified placeholder\n        desired_positions = []\n        joint_names = []\n\n        for joint_name, current_pos in self.current_joint_positions.items():\n            # In a real walking controller, this would follow gait patterns\n            # For now, use a simple oscillating pattern to simulate walking\n            phase = self.get_clock().now().nanoseconds / 1e9  # Time in seconds\n            if \'hip\' in joint_name or \'knee\' in joint_name:\n                # Add walking motion to leg joints\n                walking_offset = 0.1 * math.sin(phase * 2)  # 2 Hz walking frequency\n                desired_pos = current_pos + walking_offset\n            else:\n                desired_pos = current_pos\n\n            desired_positions.append(desired_pos)\n            joint_names.append(joint_name)\n\n        # Send trajectory command\n        self.send_joint_trajectory(joint_names, desired_positions)\n\n    def execute_manipulation_control(self):\n        """Execute manipulation control."""\n        # Manipulation control involves:\n        # 1. Inverse kinematics for end-effector positioning\n        # 2. Coordination with balance control\n        # 3. Force control for grasping\n\n        # This is a simplified placeholder\n        desired_positions = []\n        joint_names = []\n\n        for joint_name, current_pos in self.current_joint_positions.items():\n            # In a real manipulation controller, this would use IK\n            # For now, maintain current positions\n            desired_pos = current_pos\n            desired_positions.append(desired_pos)\n            joint_names.append(joint_name)\n\n        # Send trajectory command\n        self.send_joint_trajectory(joint_names, desired_positions)\n\n    def send_joint_trajectory(self, joint_names, positions):\n        """Send joint trajectory command to robot."""\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = joint_names\n\n        point = JointTrajectoryPoint()\n        point.positions = positions\n\n        # Set timing - in real system, this would be more precise\n        point.time_from_start.sec = 0\n        point.time_from_start.nanosec = int(1e8)  # 0.1 seconds\n\n        traj_msg.points.append(point)\n        self.joint_cmd_pub.publish(traj_msg)\n\n    def perform_safety_checks(self):\n        """Perform safety checks and emergency actions if needed."""\n        # Check if CoM is outside safe bounds\n        com = self.balance_state[\'com_position\']\n\n        # Simple safety check - in reality this would be more sophisticated\n        if abs(com[0]) > 0.3 or abs(com[1]) > 0.2:  # CoM too far from center\n            self.get_logger().warn(f\'CoM out of safe bounds: [{com[0]:.3f}, {com[1]:.3f}]\')\n            # In a real system, this might trigger emergency stopping\n            # For now, just log the warning\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    humanoid_controller = HumanoidController()\n\n    try:\n        rclpy.spin(humanoid_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        humanoid_controller.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.p,{children:"Now let's implement a simple balance controller that could work with the main controller:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# my_robot_control/my_robot_control/balance_controller.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Point, Vector3\nfrom std_msgs.msg import Float64\nimport numpy as np\n\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__(\'balance_controller\')\n\n        # Subscribers\n        self.com_sub = self.create_subscription(\n            Point,\n            \'/center_of_mass\',\n            self.com_callback,\n            10)\n\n        self.zmp_sub = self.create_subscription(\n            Point,\n            \'/zero_moment_point\',\n            self.zmp_callback,\n            10)\n\n        # Publishers\n        self.balance_correction_pub = self.create_publisher(\n            Vector3,\n            \'/balance_correction\',\n            10)\n\n        self.com_error_pub = self.create_publisher(\n            Float64,\n            \'/com_error\',\n            10)\n\n        # Internal state\n        self.current_com = np.array([0.0, 0.0, 0.0])\n        self.current_zmp = np.array([0.0, 0.0])\n        self.com_reference = np.array([0.0, 0.0])  # Desired CoM position in x-y plane\n        self.zmp_reference = np.array([0.0, 0.0])  # Desired ZMP position\n\n        # Balance controller parameters\n        self.kp_balance = 10.0  # Proportional gain for balance control\n        self.kd_balance = 2.0   # Derivative gain for balance control\n        self.com_tolerance = 0.05  # Tolerance for CoM position (meters)\n\n        # Timer for balance control loop\n        self.balance_timer = self.create_timer(0.01, self.balance_control_loop)  # 100 Hz\n\n        self.get_logger().info(\'Balance controller initialized\')\n\n    def com_callback(self, msg):\n        """Receive center of mass position."""\n        self.current_com = np.array([msg.x, msg.y, msg.z])\n\n    def zmp_callback(self, msg):\n        """Receive zero moment point position."""\n        self.current_zmp = np.array([msg.x, msg.y])\n\n    def balance_control_loop(self):\n        """Execute balance control calculations."""\n        # Calculate CoM error in x-y plane (horizontal plane)\n        com_error = self.com_reference - self.current_com[:2]\n\n        # Calculate ZMP error\n        zmp_error = self.zmp_reference - self.current_zmp\n\n        # Simple PD control for balance correction\n        balance_correction = self.kp_balance * com_error + self.kd_balance * zmp_error\n\n        # Publish balance correction commands\n        correction_msg = Vector3()\n        correction_msg.x = float(balance_correction[0])\n        correction_msg.y = float(balance_correction[1])\n        correction_msg.z = 0.0  # Height adjustment not typically needed for balance\n        self.balance_correction_pub.publish(correction_msg)\n\n        # Publish CoM error for monitoring\n        error_msg = Float64()\n        error_msg.data = float(np.linalg.norm(com_error))\n        self.com_error_pub.publish(error_msg)\n\n        # Log if balance is significantly off\n        if np.linalg.norm(com_error) > self.com_tolerance:\n            self.get_logger().warn(f\'Balance error: {np.linalg.norm(com_error):.3f}m\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    balance_controller = BalanceController()\n\n    try:\n        rclpy.spin(balance_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        balance_controller.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid control systems have specific hardware requirements:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real-time Performance"}),": Control loops typically run at 100-1000 Hz for stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Low Latency"}),": Sensor-to-actuator delays must be minimized"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Computational Power"}),": Inverse kinematics and dynamics calculations are intensive"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety Systems"}),": Dedicated safety processors for emergency stopping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Communication Bandwidth"}),": High-speed communication with all joints"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"NVIDIA Jetson platforms provide good balance of computational power and real-time capabilities for humanoid control systems."}),"\n",(0,s.jsx)(e.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,s.jsx)(e.p,{children:"Testing control systems in simulation before hardware deployment:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Terminal 1: Start Gazebo simulation with humanoid robot\nros2 launch my_robot_gazebo humanoid_world.launch.py\n\n# Terminal 2: Start the humanoid controller\nros2 run my_robot_control humanoid_controller\n\n# Terminal 3: Start the balance controller\nros2 run my_robot_control balance_controller\n\n# Terminal 4: Send control mode commands\nros2 service call /set_control_mode example_interfaces/srv/Float64MultiArray "{data: [1.0]}"  # standing mode\n\n# Terminal 5: Monitor control performance\nros2 topic echo /center_of_mass\nros2 topic echo /balance_correction\n'})}),"\n",(0,s.jsx)(e.p,{children:"Simulation allows for safe testing of control algorithms and parameter tuning before hardware deployment."}),"\n",(0,s.jsx)(e.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,s.jsx)(e.p,{children:"For real hardware deployment:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety First"}),": Implement comprehensive safety systems and emergency stops"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Calibration"}),": Calibrate all sensors and actuators before control"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gradual Testing"}),": Start with simple movements, increase complexity gradually"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monitoring"}),": Continuous monitoring of all control system parameters"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Fallback Systems"}),": Ensure safe fallback behaviors when control fails"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Example of a safety-aware control node:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# my_robot_safety/my_robot_safety/safe_control_wrapper.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory\nfrom std_msgs.msg import Bool\nimport threading\nimport time\n\n\nclass SafeControlWrapper(Node):\n    def __init__(self):\n        super().__init__(\'safe_control_wrapper\')\n\n        # Publishers and subscribers\n        self.command_pub = self.create_publisher(\n            JointTrajectory,\n            \'/safe_joint_trajectory\',\n            10)\n\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10)\n\n        self.safety_status_sub = self.create_subscription(\n            Bool,\n            \'/safety_enabled\',\n            self.safety_status_callback,\n            10)\n\n        # Internal state\n        self.current_joint_states = {}\n        self.safety_enabled = True\n        self.emergency_stop_active = False\n\n        # Lock for thread safety\n        self.state_lock = threading.Lock()\n\n        # Timer for safety monitoring\n        self.safety_timer = self.create_timer(0.01, self.safety_monitor)  # 100 Hz\n\n        self.get_logger().info(\'Safe control wrapper initialized\')\n\n    def joint_state_callback(self, msg):\n        """Update current joint states."""\n        with self.state_lock:\n            for i, name in enumerate(msg.name):\n                if i < len(msg.position):\n                    self.current_joint_states[name] = {\n                        \'position\': msg.position[i],\n                        \'velocity\': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                        \'effort\': msg.effort[i] if i < len(msg.effort) else 0.0\n                    }\n\n    def safety_status_callback(self, msg):\n        """Update safety status."""\n        with self.state_lock:\n            self.safety_enabled = msg.data\n\n    def safety_monitor(self):\n        """Monitor system for safety violations."""\n        with self.state_lock:\n            if not self.safety_enabled:\n                if not self.emergency_stop_active:\n                    self.execute_emergency_stop()\n                    self.emergency_stop_active = True\n            else:\n                self.emergency_stop_active = False\n\n            # Check for other safety conditions\n            self.check_joint_limits()\n            self.check_velocity_limits()\n\n    def check_joint_limits(self):\n        """Check if any joints are approaching dangerous positions."""\n        for joint_name, state in self.current_joint_states.items():\n            pos = state[\'position\']\n            # Example: Check if joint position is approaching limits\n            # These would be defined based on your robot\'s specifications\n            if abs(pos) > 3.0:  # Example limit\n                self.get_logger().warn(f\'Joint {joint_name} approaching position limit: {pos:.3f}\')\n\n    def check_velocity_limits(self):\n        """Check if any joints are moving too fast."""\n        for joint_name, state in self.current_joint_states.items():\n            vel = abs(state[\'velocity\'])\n            # Example: Check if joint velocity is too high\n            if vel > 5.0:  # Example limit (rad/s)\n                self.get_logger().warn(f\'Joint {joint_name} velocity too high: {vel:.3f}\')\n\n    def execute_emergency_stop(self):\n        """Execute emergency stop procedure."""\n        self.get_logger().error(\'EMERGENCY STOP ACTIVATED\')\n        # Send zero commands to all joints\n        self.send_zero_commands()\n\n    def send_zero_commands(self):\n        """Send zero position commands to all joints."""\n        # Create trajectory with zero positions\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = list(self.current_joint_states.keys())\n\n        point = JointTrajectoryPoint()\n        point.positions = [0.0] * len(traj_msg.joint_names)\n        point.time_from_start.sec = 0\n        point.time_from_start.nanosec = int(1e8)  # 0.1 seconds\n\n        traj_msg.points.append(point)\n        self.command_pub.publish(traj_msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safe_control_wrapper = SafeControlWrapper()\n\n    try:\n        rclpy.spin(safe_control_wrapper)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        safe_control_wrapper.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Verify control system initializes and subscribes to sensor data"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Confirm trajectory commands are published correctly"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Test safety system activation and response"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Validate balance control algorithms"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Check real-time performance requirements"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Verify emergency stop functionality"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Kajita, S., Kanehiro, F., Kaneko, K., Yokoi, K., & Hirukawa, H. (2003). The 3D linear inverted pendulum mode: a simple modeling for a biped walking pattern generation. ",(0,s.jsx)(e.em,{children:"Proceedings 2001 IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 2, 239-246."]}),"\n",(0,s.jsxs)(e.li,{children:["Pratt, J., Chew, C. M., Torres, A., Dilworth, P., & Pratt, G. (2001). Virtual model control: Toward walking machines. ",(0,s.jsx)(e.em,{children:"Proceedings 1997 IEEE International Conference on Robotics and Automation"}),", 3, 2260-2267."]}),"\n",(0,s.jsxs)(e.li,{children:["Hofmann, A., Deits, R., & Tedrake, R. (2015). Convex-based stepping stabilization for the 3D linear inverted pendulum balance controller with changing support. ",(0,s.jsx)(e.em,{children:"2015 IEEE International Conference on Robotics and Automation (ICRA)"}),", 4991-4998."]}),"\n",(0,s.jsxs)(e.li,{children:["Wensing, P. M., & Orin, D. E. (2013). Improved computation of the Jacobian matrices for inverse dynamics in robotics. ",(0,s.jsx)(e.em,{children:"The International Journal of Robotics Research"}),", 32(10), 1225-1235."]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>i,x:()=>a});var t=o(6540);const s={},r=t.createContext(s);function i(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);