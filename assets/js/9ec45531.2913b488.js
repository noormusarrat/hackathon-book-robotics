"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2842],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},9916:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros2/chapter-5","title":"Chapter 5: ROS 2 for Humanoid Robots","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-1-ros2/chapter-5.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-5","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-1-ros2/chapter-5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Humanoid Robot Control Systems","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-4"},"next":{"title":"Chapter 6: ROS 2 Pipeline Implementation","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-6"}}');var i=t(4848),o=t(8453);const a={sidebar_position:5},r="Chapter 5: ROS 2 for Humanoid Robots",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function f(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-5-ros-2-for-humanoid-robots",children:"Chapter 5: ROS 2 for Humanoid Robots"})}),"\n",(0,i.jsx)(n.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides the essential infrastructure for developing complex humanoid robots, but humanoid-specific challenges require specialized approaches. Unlike simpler robots, humanoids must handle complex kinematics, balance control, coordinated multi-limb motion, and human interaction. This chapter explores how ROS 2's features can be leveraged to address these unique challenges while maintaining the modularity and flexibility that make ROS 2 powerful."}),"\n",(0,i.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robots present several unique challenges that require specialized ROS 2 approaches:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complex Kinematics"}),": Humanoid robots typically have 20+ degrees of freedom with complex kinematic chains. This requires sophisticated forward and inverse kinematics solutions that can run in real-time."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Balance and Locomotion"}),": Bipedal locomotion requires continuous balance control, making real-time performance and low-latency communication critical."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multi-Modal Interaction"}),": Humanoids must integrate multiple sensory modalities (vision, touch, audio) with complex motor behaviors."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Safety Requirements"}),": The human-like form factor creates unique safety challenges, requiring comprehensive safety systems."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Real-time Constraints"}),": Many humanoid behaviors require hard real-time performance for stability and safety."]}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 addresses these challenges through:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time capabilities"}),": Support for real-time systems with deterministic behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distributed architecture"}),": Enables modular development of complex systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication QoS"}),": Quality of Service profiles for different message types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lifecycle management"}),": Proper initialization and cleanup of complex systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security features"}),": Authentication and encryption for safe operation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Let's implement a humanoid-specific ROS 2 system that addresses these challenges:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_humanoid/my_robot_humanoid/humanoid_manager.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Pose, Twist\nfrom std_msgs.msg import String, Bool, Float64MultiArray\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport threading\nimport time\nfrom collections import deque\n\n\nclass HumanoidManager(Node):\n    def __init__(self):\n        super().__init__('humanoid_manager')\n\n        # Define QoS profiles for different types of data\n        self.sensor_qos = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        self.control_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        self.status_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL\n        )\n\n        # Subscribers for sensor data\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            self.sensor_qos)\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            self.sensor_qos)\n\n        self.tf_sub = self.create_subscription(\n            # In a real system, this would be tf2_msgs/TFMessage\n            # For this example, using a simple pose message\n            Pose,\n            '/robot_pose',\n            self.pose_callback,\n            self.sensor_qos)\n\n        # Publishers for control and status\n        self.status_pub = self.create_publisher(\n            String,\n            '/humanoid_status',\n            self.status_qos)\n\n        self.safety_pub = self.create_publisher(\n            Bool,\n            '/safety_status',\n            self.status_qos)\n\n        self.command_pub = self.create_publisher(\n            Float64MultiArray,\n            '/humanoid_commands',\n            self.control_qos)\n\n        # Services for humanoid-specific operations\n        self.stand_srv = self.create_service(\n            String,\n            'request_stand',\n            self.request_stand_callback)\n\n        self.walk_srv = self.create_service(\n            String,\n            'request_walk',\n            self.request_walk_callback)\n\n        self.sit_srv = self.create_service(\n            String,\n            'request_sit',\n            self.request_sit_callback)\n\n        # Internal state\n        self.joint_states = {}\n        self.imu_data = {}\n        self.robot_pose = Pose()\n        self.current_behavior = 'idle'\n        self.safety_enabled = True\n        self.emergency_stop = False\n\n        # Joint state history for velocity estimation\n        self.joint_history = {}\n        self.history_length = 5\n\n        # Safety thresholds\n        self.safety_thresholds = {\n            'imu_angular_velocity': 10.0,  # rad/s\n            'imu_linear_acceleration': 50.0,  # m/s^2\n            'joint_velocity': 10.0,  # rad/s\n            'joint_effort': 100.0  # Nm (example)\n        }\n\n        # Timer for main control loop\n        self.main_loop_timer = self.create_timer(0.01, self.main_control_loop)  # 100 Hz\n\n        # Timer for safety monitoring\n        self.safety_timer = self.create_timer(0.005, self.safety_monitor)  # 200 Hz\n\n        self.get_logger().info('Humanoid manager initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process joint state messages with history for velocity estimation.\"\"\"\n        current_time = self.get_clock().now().nanoseconds / 1e9\n\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                pos = msg.position[i]\n\n                # Store in joint states\n                self.joint_states[name] = {\n                    'position': pos,\n                    'velocity': 0.0,\n                    'effort': 0.0\n                }\n\n                if i < len(msg.velocity):\n                    self.joint_states[name]['velocity'] = msg.velocity[i]\n                if i < len(msg.effort):\n                    self.joint_states[name]['effort'] = msg.effort[i]\n\n                # Store history for velocity estimation if needed\n                if name not in self.joint_history:\n                    self.joint_history[name] = deque(maxlen=self.history_length)\n\n                self.joint_history[name].append((current_time, pos))\n\n                # Estimate velocity if not provided by sensor\n                if len(msg.velocity) <= i and len(self.joint_history[name]) >= 2:\n                    # Calculate velocity from position history\n                    old_time, old_pos = self.joint_history[name][0]\n                    new_time, new_pos = self.joint_history[name][-1]\n                    if new_time != old_time:\n                        estimated_vel = (new_pos - old_pos) / (new_time - old_time)\n                        self.joint_states[name]['velocity'] = estimated_vel\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for balance and orientation.\"\"\"\n        self.imu_data = {\n            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],\n            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],\n            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]\n        }\n\n    def pose_callback(self, msg):\n        \"\"\"Process robot pose information.\"\"\"\n        self.robot_pose = msg\n\n    def request_stand_callback(self, request, response):\n        \"\"\"Handle stand request.\"\"\"\n        if self.safety_check():\n            self.current_behavior = 'standing'\n            self.execute_behavior('standing')\n            response.data = 'Standing command accepted'\n            self.get_logger().info('Standing command accepted')\n        else:\n            response.data = 'Safety check failed - standing command rejected'\n            self.get_logger().warn('Standing command rejected due to safety check')\n\n        return response\n\n    def request_walk_callback(self, request, response):\n        \"\"\"Handle walk request.\"\"\"\n        if self.safety_check() and self.current_behavior != 'walking':\n            self.current_behavior = 'walking'\n            self.execute_behavior('walking')\n            response.data = 'Walking command accepted'\n            self.get_logger().info('Walking command accepted')\n        else:\n            response.data = 'Safety check failed or already walking - walking command rejected'\n            self.get_logger().warn('Walking command rejected')\n\n        return response\n\n    def request_sit_callback(self, request, response):\n        \"\"\"Handle sit request.\"\"\"\n        if self.safety_check():\n            self.current_behavior = 'sitting'\n            self.execute_behavior('sitting')\n            response.data = 'Sitting command accepted'\n            self.get_logger().info('Sitting command accepted')\n        else:\n            response.data = 'Safety check failed - sitting command rejected'\n            self.get_logger().warn('Sitting command rejected')\n\n        return response\n\n    def safety_check(self):\n        \"\"\"Perform safety checks before executing commands.\"\"\"\n        if not self.safety_enabled:\n            return False\n\n        # Check IMU data for dangerous accelerations\n        if 'linear_acceleration' in self.imu_data:\n            lin_acc = np.array(self.imu_data['linear_acceleration'])\n            if np.linalg.norm(lin_acc) > self.safety_thresholds['imu_linear_acceleration']:\n                self.get_logger().warn(f'Dangerous linear acceleration detected: {np.linalg.norm(lin_acc)}')\n                return False\n\n        # Check joint states for dangerous conditions\n        for joint_name, state in self.joint_states.items():\n            if abs(state['velocity']) > self.safety_thresholds['joint_velocity']:\n                self.get_logger().warn(f'Dangerous velocity on joint {joint_name}: {state[\"velocity\"]}')\n                return False\n\n            if abs(state['effort']) > self.safety_thresholds['joint_effort']:\n                self.get_logger().warn(f'Dangerous effort on joint {joint_name}: {state[\"effort\"]}')\n                return False\n\n        return True\n\n    def execute_behavior(self, behavior):\n        \"\"\"Execute the specified behavior.\"\"\"\n        # This would call specific behavior controllers\n        # For this example, we'll just send a command\n        cmd_msg = Float64MultiArray()\n\n        if behavior == 'standing':\n            # Send commands for standing position\n            cmd_msg.data = [0.0] * 12  # Example: 12 joints in standing position\n        elif behavior == 'walking':\n            # Send commands for walking gait\n            cmd_msg.data = [0.1] * 12  # Example: 12 joints in walking position\n        elif behavior == 'sitting':\n            # Send commands for sitting position\n            cmd_msg.data = [-0.1] * 12  # Example: 12 joints in sitting position\n\n        self.command_pub.publish(cmd_msg)\n\n    def main_control_loop(self):\n        \"\"\"Main control loop for humanoid behaviors.\"\"\"\n        # Update status\n        status_msg = String()\n        status_msg.data = f'Behavior: {self.current_behavior}, Safety: {self.safety_enabled}'\n        self.status_pub.publish(status_msg)\n\n        # Execute current behavior\n        if self.current_behavior != 'idle' and self.safety_enabled:\n            self.execute_behavior(self.current_behavior)\n\n    def safety_monitor(self):\n        \"\"\"Continuous safety monitoring.\"\"\"\n        safety_status = Bool()\n\n        # Perform safety checks\n        is_safe = self.safety_check()\n        safety_status.data = is_safe\n\n        # Publish safety status\n        self.safety_pub.publish(safety_status)\n\n        # Log safety status changes\n        if not is_safe and self.safety_enabled:\n            self.get_logger().error('SAFETY VIOLATION DETECTED - EMERGENCY STOP')\n            self.emergency_stop = True\n            self.safety_enabled = False\n            self.current_behavior = 'emergency_stop'\n            self.execute_emergency_stop()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    humanoid_manager = HumanoidManager()\n\n    try:\n        rclpy.spin(humanoid_manager)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        humanoid_manager.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now let's implement a humanoid-specific inverse kinematics node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_humanoid/my_robot_humanoid/humanoid_ik_solver.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose, Point, Quaternion\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport math\n\n\nclass HumanoidIKSolver(Node):\n    def __init__(self):\n        super().__init__('humanoid_ik_solver')\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10)\n\n        # Publishers\n        self.left_hand_target_pub = self.create_publisher(\n            Pose,\n            '/left_hand_target',\n            10)\n\n        self.right_hand_target_pub = self.create_publisher(\n            Pose,\n            '/right_hand_target',\n            10)\n\n        self.left_foot_target_pub = self.create_publisher(\n            Pose,\n            '/left_foot_target',\n            10)\n\n        self.right_foot_target_pub = self.create_publisher(\n            Pose,\n            '/right_foot_target',\n            10)\n\n        self.ik_solution_pub = self.create_publisher(\n            Float64MultiArray,\n            '/ik_solution',\n            10)\n\n        # Services for IK requests\n        self.left_hand_ik_srv = self.create_service(\n            # Using standard service for example\n            # In real system, would use custom service\n            Float64MultiArray,\n            'solve_left_hand_ik',\n            self.solve_left_hand_ik)\n\n        self.right_hand_ik_srv = self.create_service(\n            Float64MultiArray,\n            'solve_right_hand_ik',\n            self.solve_right_hand_ik)\n\n        # Internal state\n        self.current_joint_positions = {}\n        self.left_hand_pose = Pose()\n        self.right_hand_pose = Pose()\n        self.left_foot_pose = Pose()\n        self.right_foot_pose = Pose()\n\n        # Robot kinematic parameters (simplified for example)\n        self.link_lengths = {\n            'upper_arm': 0.3,  # meters\n            'forearm': 0.25,\n            'thigh': 0.4,\n            'shin': 0.4,\n            'torso': 0.6\n        }\n\n        # Timer for IK solution updates\n        self.ik_timer = self.create_timer(0.05, self.ik_update_loop)  # 20 Hz\n\n        self.get_logger().info('Humanoid IK solver initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint positions.\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.current_joint_positions[name] = msg.position[i]\n\n    def solve_left_hand_ik(self, request, response):\n        \"\"\"Solve inverse kinematics for left hand.\"\"\"\n        if len(request.data) >= 7:  # x, y, z, qx, qy, qz, qw\n            target_pose = Pose()\n            target_pose.position.x = request.data[0]\n            target_pose.position.y = request.data[1]\n            target_pose.position.z = request.data[2]\n            target_pose.orientation.x = request.data[3]\n            target_pose.orientation.y = request.data[4]\n            target_pose.orientation.z = request.data[5]\n            target_pose.orientation.w = request.data[6]\n\n            # Store as target\n            self.left_hand_pose = target_pose\n\n            # Solve IK (simplified for example)\n            solution = self.calculate_arm_ik(\n                target_pose,\n                side='left',\n                current_positions=self.current_joint_positions\n            )\n\n            # Publish solution\n            solution_msg = Float64MultiArray()\n            solution_msg.data = solution\n            self.ik_solution_pub.publish(solution_msg)\n\n            response.data = [1.0]  # Success\n        else:\n            response.data = [0.0]  # Failure\n\n        return response\n\n    def solve_right_hand_ik(self, request, response):\n        \"\"\"Solve inverse kinematics for right hand.\"\"\"\n        if len(request.data) >= 7:  # x, y, z, qx, qy, qz, qw\n            target_pose = Pose()\n            target_pose.position.x = request.data[0]\n            target_pose.position.y = request.data[1]\n            target_pose.position.z = request.data[2]\n            target_pose.orientation.x = request.data[3]\n            target_pose.orientation.y = request.data[4]\n            target_pose.orientation.z = request.data[5]\n            target_pose.orientation.w = request.data[6]\n\n            # Store as target\n            self.right_hand_pose = target_pose\n\n            # Solve IK (simplified for example)\n            solution = self.calculate_arm_ik(\n                target_pose,\n                side='right',\n                current_positions=self.current_joint_positions\n            )\n\n            # Publish solution\n            solution_msg = Float64MultiArray()\n            solution_msg.data = solution\n            self.ik_solution_pub.publish(solution_msg)\n\n            response.data = [1.0]  # Success\n        else:\n            response.data = [0.0]  # Failure\n\n        return response\n\n    def calculate_arm_ik(self, target_pose, side='left', current_positions=None):\n        \"\"\"\n        Simplified inverse kinematics for humanoid arm.\n        In a real implementation, this would use more sophisticated algorithms.\n        \"\"\"\n        # Extract target position\n        target_pos = np.array([\n            target_pose.position.x,\n            target_pose.position.y,\n            target_pose.position.z\n        ])\n\n        # Calculate basic arm IK (simplified)\n        # This is a placeholder - real IK would be much more complex\n        solution = []\n\n        # For example, return some joint angles based on target position\n        # In reality, this would solve the full kinematic chain\n        if side == 'left':\n            # Example joint positions for left arm\n            solution = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]  # Placeholder values\n        else:  # right\n            # Example joint positions for right arm\n            solution = [-0.1, 0.2, -0.3, 0.4, -0.5, 0.6]  # Placeholder values\n\n        return solution\n\n    def calculate_leg_ik(self, target_pose, side='left'):\n        \"\"\"\n        Simplified inverse kinematics for humanoid leg.\n        \"\"\"\n        # Extract target position\n        target_pos = np.array([\n            target_pose.position.x,\n            target_pose.position.y,\n            target_pose.position.z\n        ])\n\n        # Calculate basic leg IK (simplified)\n        # This is a placeholder - real IK would be much more complex\n        solution = []\n\n        # For example, return some joint angles based on target position\n        if side == 'left':\n            # Example joint positions for left leg\n            solution = [0.0, -0.5, 0.5, 0.0, 0.0, 0.0]  # Placeholder values\n        else:  # right\n            # Example joint positions for right leg\n            solution = [0.0, -0.5, 0.5, 0.0, 0.0, 0.0]  # Placeholder values\n\n        return solution\n\n    def ik_update_loop(self):\n        \"\"\"Update IK solutions and publish targets.\"\"\"\n        # Publish current targets for visualization\n        self.left_hand_target_pub.publish(self.left_hand_pose)\n        self.right_hand_target_pub.publish(self.right_hand_pose)\n        self.left_foot_target_pub.publish(self.left_foot_pose)\n        self.right_foot_target_pub.publish(self.right_foot_pose)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ik_solver = HumanoidIKSolver()\n\n    try:\n        rclpy.spin(ik_solver)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        ik_solver.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid-specific ROS 2 implementations have demanding hardware requirements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time Kernel"}),": Use real-time kernel patches for deterministic behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-core Processing"}),": Distribute different control tasks across CPU cores"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GPU Acceleration"}),": Use for inverse kinematics, computer vision, and other intensive computations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low-latency Communication"}),": Use appropriate QoS settings and network configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Processors"}),": Dedicated safety systems for emergency stopping"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For NVIDIA Jetson platforms, leverage the GPU for vision processing and use the real-time capabilities of the ARM cores for control."}),"\n",(0,i.jsx)(n.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,i.jsx)(n.p,{children:"Testing humanoid-specific ROS 2 systems in simulation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Terminal 1: Start humanoid robot simulation in Gazebo\nros2 launch my_robot_gazebo op3_world.launch.py\n\n# Terminal 2: Start the humanoid manager\nros2 run my_robot_humanoid humanoid_manager\n\n# Terminal 3: Start the IK solver\nros2 run my_robot_humanoid humanoid_ik_solver\n\n# Terminal 4: Send commands to the robot\nros2 service call /request_stand std_msgs/srv/String "{data: \'stand\'}"\n\n# Terminal 5: Monitor the system\nros2 topic echo /humanoid_status\nros2 topic echo /safety_status\n\n# Terminal 6: Send IK requests\nros2 service call /solve_left_hand_ik example_interfaces/srv/Float64MultiArray "{data: [0.3, 0.2, 0.8, 0.0, 0.0, 0.0, 1.0]}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Simulation allows for safe testing of complex humanoid behaviors before hardware deployment."}),"\n",(0,i.jsx)(n.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,i.jsx)(n.p,{children:"For real hardware deployment:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety First"}),": Ensure all safety systems are operational before enabling hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calibration"}),": Calibrate all sensors and actuators to match simulation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gradual Testing"}),": Start with simple movements, increase complexity gradually"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Continuous monitoring of all safety parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fallback Systems"}),": Ensure safe fallback behaviors when control fails"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example of a safety-aware humanoid system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# my_robot_safety/my_robot_safety/humanoid_safety_manager.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist, WrenchStamped\nfrom std_msgs.msg import Bool, String\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport threading\n\n\nclass HumanoidSafetyManager(Node):\n    def __init__(self):\n        super().__init__('humanoid_safety_manager')\n\n        # Subscribers for all safety-critical data\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10)\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            10)\n\n        self.force_sub = self.create_subscription(\n            # In a real system, this would be WrenchStamped\n            # For this example, using Float64MultiArray\n            Float64MultiArray,\n            '/force_torque',\n            self.force_callback,\n            10)\n\n        # Publishers for safety status\n        self.safety_status_pub = self.create_publisher(\n            Bool,\n            '/safety_status',\n            10)\n\n        self.emergency_stop_pub = self.create_publisher(\n            Bool,\n            '/emergency_stop',\n            10)\n\n        self.safety_log_pub = self.create_publisher(\n            String,\n            '/safety_log',\n            10)\n\n        # Internal state\n        self.joint_states = {}\n        self.imu_data = {}\n        self.force_data = {}\n        self.safety_enabled = True\n        self.emergency_stop_active = False\n        self.safety_violations = []\n\n        # Safety thresholds\n        self.safety_thresholds = {\n            'imu_angular_velocity_max': 5.0,  # rad/s\n            'imu_linear_acceleration_max': 20.0,  # m/s^2\n            'imu_orientation_threshold': 0.5,  # rad from upright\n            'joint_position_min': -3.0,  # rad\n            'joint_position_max': 3.0,   # rad\n            'joint_velocity_max': 8.0,   # rad/s\n            'joint_effort_max': 50.0,    # Nm\n            'force_threshold': 100.0,    # N\n        }\n\n        # Timer for safety monitoring\n        self.safety_timer = self.create_timer(0.001, self.safety_monitor)  # 1000 Hz\n\n        # Timer for safety status publishing\n        self.status_timer = self.create_timer(0.1, self.publish_safety_status)  # 10 Hz\n\n        self.get_logger().info('Humanoid safety manager initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process joint state messages for safety monitoring.\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                pos = msg.position[i]\n                vel = msg.velocity[i] if i < len(msg.velocity) else 0.0\n                effort = msg.effort[i] if i < len(msg.effort) else 0.0\n\n                self.joint_states[name] = {\n                    'position': pos,\n                    'velocity': vel,\n                    'effort': effort\n                }\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for orientation and acceleration safety.\"\"\"\n        self.imu_data = {\n            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],\n            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],\n            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]\n        }\n\n    def force_callback(self, msg):\n        \"\"\"Process force/torque data.\"\"\"\n        if len(msg.data) >= 6:  # [force_x, force_y, force_z, torque_x, torque_y, torque_z]\n            self.force_data = {\n                'force': msg.data[0:3],\n                'torque': msg.data[3:6]\n            }\n\n    def safety_monitor(self):\n        \"\"\"Continuous safety monitoring.\"\"\"\n        violations = []\n\n        # Check IMU data\n        if self.imu_data:\n            # Check angular velocity\n            ang_vel = np.array(self.imu_data['angular_velocity'])\n            if np.linalg.norm(ang_vel) > self.safety_thresholds['imu_angular_velocity_max']:\n                violations.append(f'High angular velocity: {np.linalg.norm(ang_vel):.2f}')\n\n            # Check linear acceleration\n            lin_acc = np.array(self.imu_data['linear_acceleration'])\n            if np.linalg.norm(lin_acc) > self.safety_thresholds['imu_linear_acceleration_max']:\n                violations.append(f'High linear acceleration: {np.linalg.norm(lin_acc):.2f}')\n\n            # Check orientation (simplified - check if robot is roughly upright)\n            orientation = self.imu_data['orientation']\n            # Convert quaternion to rotation matrix and check z-axis\n            # Simplified check for this example\n            if abs(orientation[2]) > 0.7:  # If z-component of orientation is too large\n                violations.append(f'Unstable orientation: {orientation}')\n\n        # Check joint states\n        for joint_name, state in self.joint_states.items():\n            if state['position'] < self.safety_thresholds['joint_position_min']:\n                violations.append(f'Joint {joint_name} position too low: {state[\"position\"]:.2f}')\n            elif state['position'] > self.safety_thresholds['joint_position_max']:\n                violations.append(f'Joint {joint_name} position too high: {state[\"position\"]:.2f}')\n\n            if abs(state['velocity']) > self.safety_thresholds['joint_velocity_max']:\n                violations.append(f'Joint {joint_name} velocity too high: {state[\"velocity\"]:.2f}')\n\n            if abs(state['effort']) > self.safety_thresholds['joint_effort_max']:\n                violations.append(f'Joint {joint_name} effort too high: {state[\"effort\"]:.2f}')\n\n        # Check force data\n        if self.force_data:\n            force_mag = np.linalg.norm(self.force_data['force'])\n            if force_mag > self.safety_thresholds['force_threshold']:\n                violations.append(f'High force detected: {force_mag:.2f}')\n\n        # Update violations and check for emergency stop\n        self.safety_violations = violations\n\n        if violations:\n            # Log violations\n            for violation in violations:\n                self.get_logger().warn(f'Safety violation: {violation}')\n                log_msg = String()\n                log_msg.data = f'Safety violation: {violation}'\n                self.safety_log_pub.publish(log_msg)\n\n            # Trigger emergency stop if critical violations\n            if self.is_critical_violation(violations):\n                self.trigger_emergency_stop()\n\n    def is_critical_violation(self, violations):\n        \"\"\"Determine if any violations are critical enough for emergency stop.\"\"\"\n        critical_keywords = ['acceleration', 'orientation', 'force']\n        for violation in violations:\n            if any(keyword in violation.lower() for keyword in critical_keywords):\n                return True\n        return False\n\n    def trigger_emergency_stop(self):\n        \"\"\"Trigger emergency stop procedure.\"\"\"\n        if not self.emergency_stop_active:\n            self.get_logger().error('EMERGENCY STOP TRIGGERED')\n            self.emergency_stop_active = True\n            self.safety_enabled = False\n\n            # Publish emergency stop command\n            emergency_msg = Bool()\n            emergency_msg.data = True\n            self.emergency_stop_pub.publish(emergency_msg)\n\n            # Log emergency stop\n            log_msg = String()\n            log_msg.data = 'EMERGENCY STOP ACTIVATED'\n            self.safety_log_pub.publish(log_msg)\n\n    def publish_safety_status(self):\n        \"\"\"Publish current safety status.\"\"\"\n        status_msg = Bool()\n        status_msg.data = self.safety_enabled and not self.emergency_stop_active\n        self.safety_status_pub.publish(status_msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safety_manager = HumanoidSafetyManager()\n\n    try:\n        rclpy.spin(safety_manager)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        safety_manager.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify humanoid-specific ROS 2 nodes initialize correctly"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Confirm safety systems monitor all critical parameters"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test inverse kinematics solutions for accuracy"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Validate real-time performance requirements"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Check proper error handling and fallback behaviors"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Verify emergency stop functionality"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Kuffner, J., Nishiwaki, K., Kagami, S., Inaba, M., & Inoue, H. (2004). Motion planning for humanoid robots. ",(0,i.jsx)(n.em,{children:"Robotics Research"}),", 365-374."]}),"\n",(0,i.jsxs)(n.li,{children:["Nakanishi, J., Cory, R., Mistry, M., Peters, J., & Schaal, S. (2008). Operational space control: A theoretical and empirical comparison. ",(0,i.jsx)(n.em,{children:"The International Journal of Robotics Research"}),", 27(6), 737-757."]}),"\n",(0,i.jsxs)(n.li,{children:["Wensing, P. M., & Orin, D. E. (2013). Improved computation of the Jacobian matrices for inverse dynamics in robotics. ",(0,i.jsx)(n.em,{children:"The International Journal of Robotics Research"}),", 32(10), 1225-1235."]}),"\n",(0,i.jsxs)(n.li,{children:["Pratt, J., & Pratt, G. (1998). Intuitive control of a planar bipedal walking robot. ",(0,i.jsx)(n.em,{children:"Proceedings of the 1998 IEEE International Conference on Robotics and Automation"}),", 2, 1458-1465."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}}}]);