"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2424],{2851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-1-ros2/chapter-7","title":"Chapter 7 - ROS 2 Best Practices","description":"Why This Concept Matters for Humanoids","source":"@site/docs/module-1-ros2/chapter-7.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-7","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-7","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-1-ros2/chapter-7.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Chapter 7 - ROS 2 Best Practices","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 6: ROS 2 Pipeline Implementation","permalink":"/hackathon-book-robotics/docs/module-1-ros2/chapter-6"},"next":{"title":"Module 1 Exercises","permalink":"/hackathon-book-robotics/docs/module-1-ros2/exercises/"}}');var s=t(4848),o=t(8453);const r={title:"Chapter 7 - ROS 2 Best Practices",sidebar_position:7},a="Chapter 7: ROS 2 Best Practices",l={},c=[{value:"Why This Concept Matters for Humanoids",id:"why-this-concept-matters-for-humanoids",level:2},{value:"Theory",id:"theory",level:2},{value:"Implementation",id:"implementation",level:2},{value:"1. Package Structure Best Practices",id:"1-package-structure-best-practices",level:3},{value:"2. Node Design Best Practices",id:"2-node-design-best-practices",level:3},{value:"3. Launch File Best Practices",id:"3-launch-file-best-practices",level:3},{value:"4. Testing Best Practices",id:"4-testing-best-practices",level:3},{value:"Hardware/GPU Notes",id:"hardwaregpu-notes",level:2},{value:"Simulation Path",id:"simulation-path",level:2},{value:"Real-World Path",id:"real-world-path",level:2},{value:"Spec-Build-Test Checklist",id:"spec-build-test-checklist",level:2},{value:"APA Citations",id:"apa-citations",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-7-ros-2-best-practices",children:"Chapter 7: ROS 2 Best Practices"})}),"\n",(0,s.jsx)(n.h2,{id:"why-this-concept-matters-for-humanoids",children:"Why This Concept Matters for Humanoids"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 best practices are critical for humanoid robotics due to the complexity and safety requirements of these systems. Unlike simpler robots, humanoid robots involve multiple subsystems (locomotion, manipulation, perception, cognition) that must work in harmony. Following established best practices ensures code maintainability, system reliability, and safety - all essential for robots that interact closely with humans. Proper practices also facilitate collaboration among teams and enable scalable development as humanoid robot capabilities evolve."}),"\n",(0,s.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 best practices encompass architectural patterns, coding standards, and operational procedures that have been validated through years of robotic development. These practices address common challenges in robotics such as real-time constraints, fault tolerance, distributed computing, and safety. For humanoid robotics specifically, best practices must account for the additional complexity of bipedal locomotion, human-robot interaction, and the need for fail-safe mechanisms."}),"\n",(0,s.jsx)(n.p,{children:"Key principles include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),": Breaking complex systems into manageable, testable components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusability"}),": Designing components that can be used across different robots or applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety"}),": Implementing multiple layers of safety checks and fail-safe mechanisms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainability"}),": Writing code that can be understood and modified by others"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Optimizing for real-time constraints and computational efficiency"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"1-package-structure-best-practices",children:"1. Package Structure Best Practices"}),"\n",(0,s.jsx)(n.p,{children:"Follow the ROS 2 standard for organizing packages:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my_robot_package/\n\u251c\u2500\u2500 CMakeLists.txt          # Build configuration\n\u251c\u2500\u2500 package.xml            # Package metadata and dependencies\n\u251c\u2500\u2500 README.md              # Package documentation\n\u251c\u2500\u2500 config/                # Configuration files\n\u251c\u2500\u2500 launch/                # Launch files\n\u251c\u2500\u2500 src/                   # Source code\n\u251c\u2500\u2500 include/               # Header files (C++)\n\u251c\u2500\u2500 scripts/               # Executable scripts\n\u251c\u2500\u2500 test/                  # Unit and integration tests\n\u2514\u2500\u2500 docs/                  # Additional documentation\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example package.xml with proper dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>my_humanoid_control</name>\n  <version>1.0.0</version>\n  <description>Humanoid robot control package</description>\n  <maintainer email="maintainer@robotics.org">Maintainer Name</maintainer>\n  <license>Apache License 2.0</license>\n\n  <buildtool_depend>ament_cmake</buildtool_depend>\n\n  <depend>rclcpp</depend>\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n  <depend>sensor_msgs</depend>\n  <depend>geometry_msgs</depend>\n  <depend>control_msgs</depend>\n  <depend>trajectory_msgs</depend>\n\n  <test_depend>ament_lint_auto</test_depend>\n  <test_depend>ament_lint_common</test_depend>\n\n  <export>\n    <build_type>ament_cmake</build_type>\n  </export>\n</package>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-node-design-best-practices",children:"2. Node Design Best Practices"}),"\n",(0,s.jsx)(n.p,{children:"Create nodes that follow the single responsibility principle:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# my_humanoid_controller.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport threading\nimport time\n\nclass HumanoidController(Node):\n    def __init__(self):\n        super().__init__('humanoid_controller')\n\n        # Declare parameters with defaults\n        self.declare_parameter('control_rate', 100.0)\n        self.declare_parameter('max_effort', 100.0)\n        self.declare_parameter('joint_names', [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\n        ])\n\n        # Get parameters\n        self.control_rate = self.get_parameter('control_rate').value\n        self.max_effort = self.get_parameter('max_effort').value\n        self.joint_names = self.get_parameter('joint_names').value\n\n        # QoS profiles for different data types\n        sensor_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        control_qos = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # Publishers\n        self.joint_command_pub = self.create_publisher(\n            JointTrajectory, 'joint_trajectory', control_qos)\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_state_callback, sensor_qos)\n\n        # Internal state\n        self.current_joint_states = {}\n        self.trajectory_buffer = []\n\n        # Control timer\n        self.control_timer = self.create_timer(\n            1.0/self.control_rate, self.control_loop)\n\n        # Safety timer\n        self.safety_timer = self.create_timer(0.1, self.safety_check)\n\n        self.get_logger().info(\n            f'Humanoid Controller initialized with {len(self.joint_names)} joints')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint states\"\"\"\n        for i, name in enumerate(msg.name):\n            if name in self.joint_names:\n                self.current_joint_states[name] = {\n                    'position': msg.position[i],\n                    'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                    'effort': msg.effort[i] if i < len(msg.effort) else 0.0\n                }\n\n    def control_loop(self):\n        \"\"\"Main control loop\"\"\"\n        try:\n            # Process trajectory commands\n            if self.trajectory_buffer:\n                trajectory_point = self.trajectory_buffer.pop(0)\n                self.execute_trajectory_point(trajectory_point)\n\n            # Publish current state\n            self.publish_feedback()\n\n        except Exception as e:\n            self.get_logger().error(f'Error in control loop: {str(e)}')\n\n    def execute_trajectory_point(self, point):\n        \"\"\"Execute a trajectory point\"\"\"\n        # Validate trajectory point\n        if not self.validate_trajectory_point(point):\n            self.get_logger().warn('Invalid trajectory point, skipping')\n            return\n\n        # Send trajectory command\n        trajectory_msg = JointTrajectory()\n        trajectory_msg.joint_names = self.joint_names\n        trajectory_msg.points = [point]\n\n        self.joint_command_pub.publish(trajectory_msg)\n\n    def validate_trajectory_point(self, point):\n        \"\"\"Validate trajectory point for safety\"\"\"\n        # Check position limits\n        for i, pos in enumerate(point.positions):\n            if abs(pos) > np.pi * 2:  # 2 full rotations should be enough\n                return False\n\n        # Check velocity limits\n        for vel in point.velocities:\n            if abs(vel) > 10.0:  # rad/s - adjust based on joint specs\n                return False\n\n        # Check effort limits\n        for effort in point.efforts:\n            if abs(effort) > self.max_effort:\n                return False\n\n        return True\n\n    def safety_check(self):\n        \"\"\"Perform safety checks\"\"\"\n        # Check for joint limits violations\n        for name, state in self.current_joint_states.items():\n            if abs(state['position']) > 10.0:  # Example limit\n                self.emergency_stop()\n                return\n\n        # Check for excessive effort\n        for name, state in self.current_joint_states.items():\n            if abs(state['effort']) > self.max_effort * 1.2:\n                self.get_logger().warn(f'High effort detected on {name}: {state[\"effort\"]}')\n\n    def emergency_stop(self):\n        \"\"\"Emergency stop procedure\"\"\"\n        self.get_logger().error('EMERGENCY STOP ACTIVATED')\n\n        # Send zero trajectory\n        zero_point = JointTrajectoryPoint()\n        zero_point.positions = [0.0] * len(self.joint_names)\n        zero_point.velocities = [0.0] * len(self.joint_names)\n        zero_point.accelerations = [0.0] * len(self.joint_names)\n        zero_point.effort = [0.0] * len(self.joint_names)\n        zero_point.time_from_start = Duration(sec=0, nanosec=100000000)  # 100ms\n\n        trajectory_msg = JointTrajectory()\n        trajectory_msg.joint_names = self.joint_names\n        trajectory_msg.points = [zero_point]\n\n        self.joint_command_pub.publish(trajectory_msg)\n\n    def publish_feedback(self):\n        \"\"\"Publish controller feedback\"\"\"\n        # Implementation would publish controller state\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = HumanoidController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down controller...')\n    finally:\n        controller.emergency_stop()  # Ensure safe shutdown\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-launch-file-best-practices",children:"3. Launch File Best Practices"}),"\n",(0,s.jsx)(n.p,{children:"Create reusable and configurable launch files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# humanoid_control.launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, OpaqueFunction\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef launch_setup(context, *args, **kwargs):\n    # Get launch arguments\n    namespace = LaunchConfiguration('namespace').perform(context)\n    use_sim_time = LaunchConfiguration('use_sim_time').perform(context)\n\n    # Get package share directory\n    pkg_share = get_package_share_directory('my_humanoid_control')\n\n    # Create nodes\n    controller_node = Node(\n        package='my_humanoid_control',\n        executable='humanoid_controller',\n        name='humanoid_controller',\n        namespace=namespace,\n        parameters=[\n            os.path.join(pkg_share, 'config', 'controller.yaml'),\n            {\n                'use_sim_time': use_sim_time == 'true',\n                'control_rate': 100.0,\n                'max_effort': 100.0\n            }\n        ],\n        remappings=[\n            ('joint_states', f'{namespace}/joint_states'),\n            ('joint_trajectory', f'{namespace}/joint_trajectory')\n        ],\n        respawn=True,\n        respawn_delay=2\n    )\n\n    return [controller_node]\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Declare launch arguments\n        DeclareLaunchArgument(\n            'namespace',\n            default_value='humanoid_robot',\n            description='Robot namespace'\n        ),\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='false',\n            choices=['true', 'false'],\n            description='Use simulation time'\n        ),\n\n        # Opaque function to handle complex logic\n        OpaqueFunction(function=launch_setup)\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-testing-best-practices",children:"4. Testing Best Practices"}),"\n",(0,s.jsx)(n.p,{children:"Create comprehensive tests for your ROS 2 nodes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# test_humanoid_controller.py\n\nimport unittest\nimport rclpy\nfrom rclpy.executors import SingleThreadedExecutor\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport time\nfrom my_humanoid_control.my_humanoid_controller import HumanoidController\n\nclass TestHumanoidController(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.node = HumanoidController()\n        self.executor = SingleThreadedExecutor()\n        self.executor.add_node(self.node)\n\n    def tearDown(self):\n        self.node.destroy_node()\n\n    def test_node_initialization(self):\n        """Test that node initializes correctly"""\n        self.assertIsNotNone(self.node)\n        self.assertEqual(len(self.node.joint_names), 6)  # Default joint count\n\n    def test_joint_state_callback(self):\n        """Test joint state subscription"""\n        # Create test joint state message\n        joint_state_msg = JointState()\n        joint_state_msg.name = [\'left_hip_joint\', \'left_knee_joint\']\n        joint_state_msg.position = [0.1, 0.2]\n        joint_state_msg.velocity = [0.0, 0.0]\n        joint_state_msg.effort = [0.0, 0.0]\n\n        # Publish and spin to process\n        pub = self.node.create_publisher(JointState, \'joint_states\', 10)\n        pub.publish(joint_state_msg)\n\n        # Allow time for processing\n        start_time = time.time()\n        while time.time() - start_time < 1.0:\n            self.executor.spin_once(timeout_sec=0.1)\n            if \'left_hip_joint\' in self.node.current_joint_states:\n                break\n\n        # Verify state was updated\n        self.assertIn(\'left_hip_joint\', self.node.current_joint_states)\n        self.assertEqual(\n            self.node.current_joint_states[\'left_hip_joint\'][\'position\'], 0.1)\n\n    def test_trajectory_validation(self):\n        """Test trajectory validation"""\n        # Valid trajectory point\n        valid_point = JointTrajectoryPoint()\n        valid_point.positions = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n        valid_point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        valid_point.efforts = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0]\n        valid_point.time_from_start = Duration(sec=1, nanosec=0)\n\n        self.assertTrue(self.node.validate_trajectory_point(valid_point))\n\n        # Invalid trajectory point (excessive position)\n        invalid_point = JointTrajectoryPoint()\n        invalid_point.positions = [100.0, 0.2, 0.3, 0.4, 0.5, 0.6]  # Too large\n        invalid_point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        invalid_point.efforts = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0]\n        invalid_point.time_from_start = Duration(sec=1, nanosec=0)\n\n        self.assertFalse(self.node.validate_trajectory_point(invalid_point))\n\ndef main():\n    unittest.main()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hardwaregpu-notes",children:"Hardware/GPU Notes"}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robotics, hardware considerations are critical to success:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time Performance"}),": Use PREEMPT_RT kernel for deterministic timing in control loops"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Computational Power"}),": Multi-core processors (8+ cores) with high single-core performance for real-time control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": 32GB+ RAM for complex perception and planning algorithms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPU"}),": NVIDIA GPU with CUDA support (RTX 4070 Ti minimum) for accelerated perception"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network"}),": Dedicated network interface for robot communication to avoid interference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Power Management"}),": Consider power consumption and thermal management for mobile robots"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Systems"}),": Hardware-based safety mechanisms as backup to software safety"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"simulation-path",children:"Simulation Path"}),"\n",(0,s.jsx)(n.p,{children:"When developing with simulation, follow these best practices:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Simulation-Specific Parameters"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# In your node\nuse_sim_time = self.declare_parameter('use_sim_time', False).value\nif use_sim_time:\n    # Use different parameters for simulation\n    self.control_rate = 50.0  # Slower for simulation\nelse:\n    self.control_rate = 100.0  # Full speed for real robot\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Model Fidelity Considerations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start with simplified models for development"}),"\n",(0,s.jsx)(n.li,{children:"Gradually increase complexity as needed"}),"\n",(0,s.jsx)(n.li,{children:"Validate simulation results against real hardware regularly"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simulation Testing Pipeline"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unit tests for individual nodes"}),"\n",(0,s.jsx)(n.li,{children:"Integration tests in simulation"}),"\n",(0,s.jsx)(n.li,{children:"System tests on real hardware"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"real-world-path",children:"Real-World Path"}),"\n",(0,s.jsx)(n.p,{children:"For deployment on real humanoid hardware:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Safety First"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement multiple safety layers"}),"\n",(0,s.jsx)(n.li,{children:"Test all emergency procedures"}),"\n",(0,s.jsx)(n.li,{children:"Use safety-rated hardware where possible"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gradual Deployment"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start with simple movements in safe environment"}),"\n",(0,s.jsx)(n.li,{children:"Gradually increase complexity"}),"\n",(0,s.jsx)(n.li,{children:"Monitor system behavior continuously"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hardware Validation"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Calibrate all sensors before deployment"}),"\n",(0,s.jsx)(n.li,{children:"Verify communication reliability"}),"\n",(0,s.jsx)(n.li,{children:"Test in various environmental conditions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"spec-build-test-checklist",children:"Spec-Build-Test Checklist"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All packages follow ROS 2 naming conventions"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Dependencies are properly declared in package.xml"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Launch files are configurable via parameters"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","QoS profiles are appropriate for each use case"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Safety mechanisms are implemented and tested"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Code follows style guidelines (ament_uncrustify, etc.)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Comprehensive unit and integration tests exist"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Documentation is complete and up-to-date"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Performance is profiled and optimized"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error handling covers all possible failure modes"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Parameter validation prevents invalid configurations"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Emergency stop functionality is robust"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Kammerl, J., Holzer, S., Rusu, R. B., & Konolige, K. (2012). Real-time automated parameter tuning for multi-dimensional point cloud processing. ",(0,s.jsx)(n.em,{children:"Proceedings of the IEEE International Conference on Robotics and Automation (ICRA)"}),", 2459-2465."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Quigley, M., Gerkey, B., & Smart, W. D. (2009). Programming robots with ROS: A practical introduction to the Robot Operating System. ",(0,s.jsx)(n.em,{children:"Communications of the ACM"}),", 57(9), 82-91."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Foote, T., Lalancette, C., & Quigley, J. (2016). ROS 2: Towards a robot platform for next generation robots. ",(0,s.jsx)(n.em,{children:"Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)"}),", 4698-4704."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Open Robotics. (2021). ROS 2 Documentation: Best Practices. Retrieved from ",(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Code-Style-Language-Versions.html",children:"https://docs.ros.org/en/rolling/The-ROS2-Project/Contributing/Code-Style-Language-Versions.html"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["L\xfctkebohle, I., & Axer, P. (2018). Design patterns for ROS-based systems: Engineering software for robots. ",(0,s.jsx)(n.em,{children:"Proceedings of the Workshop on Software Engineering for Robotics"}),", 1-6."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);