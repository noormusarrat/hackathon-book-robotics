"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1046],{4815:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vla/chapter-5","title":"Chapter 26: Action Planning from Language","description":"Converting natural language commands into executable robot action sequences","source":"@site/docs/module-4-vla/chapter-5.md","sourceDirName":"module-4-vla","slug":"/module-4-vla/chapter-5","permalink":"/hackathon-book-robotics/docs/module-4-vla/chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/noormusarrat/hackathon-book-robotics/edit/main/docs/module-4-vla/chapter-5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Chapter 26: Action Planning from Language","description":"Converting natural language commands into executable robot action sequences"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 25: Natural Language Understanding","permalink":"/hackathon-book-robotics/docs/module-4-vla/chapter-4"},"next":{"title":"Module 4: VLA Robotics - Language to Action","permalink":"/hackathon-book-robotics/docs/module-4-vla/"}}');var a=i(4848),s=i(8453);const o={sidebar_position:5,title:"Chapter 26: Action Planning from Language",description:"Converting natural language commands into executable robot action sequences"},l="Chapter 26: Action Planning from Language",r={},c=[{value:"1. Why this concept matters for humanoids",id:"1-why-this-concept-matters-for-humanoids",level:2},{value:"2. Theory",id:"2-theory",level:2},{value:"3. Implementation",id:"3-implementation",level:2},{value:"4. Hardware/GPU Notes",id:"4-hardwaregpu-notes",level:2},{value:"5. Simulation Path",id:"5-simulation-path",level:2},{value:"6. Real-World Path",id:"6-real-world-path",level:2},{value:"7. Spec-Build-Test checklist",id:"7-spec-build-test-checklist",level:2},{value:"8. APA citations",id:"8-apa-citations",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-26-action-planning-from-language",children:"Chapter 26: Action Planning from Language"})}),"\n",(0,a.jsx)(e.h2,{id:"1-why-this-concept-matters-for-humanoids",children:"1. Why this concept matters for humanoids"}),"\n",(0,a.jsx)(e.p,{children:'Action planning from language is the critical bridge between human communication and robot execution for humanoid robots. While natural language understanding interprets what a human wants, action planning determines how the robot will achieve that goal through a sequence of executable actions. This capability enables humanoid robots to translate high-level, abstract commands like "Clean up the table" into specific, coordinated movements of arms, legs, and other actuators. Without effective action planning, even the best language understanding system would be useless if the robot cannot execute the desired behavior safely and efficiently.'}),"\n",(0,a.jsx)(e.h2,{id:"2-theory",children:"2. Theory"}),"\n",(0,a.jsx)(e.p,{children:"Action planning from language involves several key components that work together to transform linguistic commands into robot behavior:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Task Decomposition"}),': Breaking down high-level commands into sequences of primitive actions that the robot can execute. For example, "Pick up the red cup and place it on the table" decomposes into: navigate to cup, identify red cup, grasp cup, navigate to table, place cup.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Symbolic Planning"}),": Creating symbolic representations of the world state, goals, and actions using formalisms like STRIPS (Stanford Research Institute Problem Solver) or PDDL (Planning Domain Definition Language). These representations enable automated planning algorithms to find sequences of actions that achieve the goal."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Grounded Action Mapping"}),': Connecting abstract linguistic concepts to concrete robot capabilities. This involves mapping language-derived goals to specific robot action primitives like "move_to", "grasp", "navigate", etc.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Constraint Handling"}),": Managing physical, temporal, and safety constraints during planning. This includes collision avoidance, joint limits, workspace boundaries, and safety considerations."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Reactive Planning"}),": Adapting plans in real-time based on environmental changes or plan execution failures. This allows robots to handle unexpected obstacles or changes in the environment."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Multi-modal Integration"}),": Combining language-derived goals with visual perception, spatial reasoning, and other sensory inputs to create robust plans that account for the actual state of the world."]}),"\n",(0,a.jsx)(e.h2,{id:"3-implementation",children:"3. Implementation"}),"\n",(0,a.jsx)(e.p,{children:"Let's implement an action planning system that converts language-based goals into executable robot actions. The implementation centers around an ActionPlanner class that maps natural language commands to sequences of robot actions."}),"\n",(0,a.jsx)(e.p,{children:"The system uses a RobotAction data structure with action type (NAVIGATION, MANIPULATION, PERCEPTION, INTERACTION), action name, and parameters. The planner defines robot capabilities for each action type and maps language intents to executable actions."}),"\n",(0,a.jsx)(e.p,{children:"Key implementation components include:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Intent Processing"}),": Converting language intents (navigation, manipulation, interaction) to action sequences"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Location Resolution"}),": Mapping location names to poses in the environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Object Handling"}),": Finding objects and determining appropriate manipulation actions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Action Validation"}),": Ensuring planned actions are executable by the robot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Execution Interface"}),": Connecting to the robot's control systems"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Core Action Planner implementation\nclass ActionPlanner(Node):\n    def __init__(self, node):\n        super().__init__('action_planner')\n        self.node = node\n\n        # Initialize interfaces for manipulation and navigation\n        self.move_group = MoveGroupInterface(\"arm\", \"robot_description\")\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self.node)\n\n        # Define robot capabilities\n        self.robot_capabilities = self.define_robot_capabilities()\n        self.action_pub = self.node.create_publisher(String, '/robot/action_sequence', 10)\n\n        self.get_logger().info('Action Planner initialized')\n\n    def plan_action_from_language(self, intent_data: Dict) -> List[RobotAction]:\n        \"\"\"Plan robot actions based on language intent data\"\"\"\n        intent = intent_data.get('intent', 'none')\n        action = intent_data.get('action', {})\n\n        if intent == 'navigation':\n            return self.plan_navigation_action(action)\n        elif intent == 'manipulation':\n            return self.plan_manipulation_action(action)\n        elif intent == 'interaction':\n            return self.plan_interaction_action(action)\n        else:\n            return self.plan_default_action(action)\n\n    def plan_navigation_action(self, action: Dict) -> List[RobotAction]:\n        \"\"\"Plan navigation actions based on language input\"\"\"\n        actions = []\n        if action['action'] in ['move_to', 'navigate_to', 'go_to']:\n            target_location = self.resolve_location(action.get('target', ''))\n            nav_action = RobotAction(\n                action_type=ActionType.NAVIGATION,\n                action_name='move_to',\n                parameters={'target_pose': target_location}\n            )\n            actions.append(nav_action)\n        return actions\n\n    # Additional methods for manipulation and interaction planning\n    # ... (plan_manipulation_action, plan_interaction_action, etc.)\n"})}),"\n",(0,a.jsx)(e.p,{children:"The system also includes integration with NLU through a LanguageActionInterface that subscribes to structured commands and publishes action sequences. For more sophisticated planning, a PDDL-based planning domain can be defined with types, predicates, and actions for formal planning approaches."}),"\n",(0,a.jsx)(e.h2,{id:"4-hardwaregpu-notes",children:"4. Hardware/GPU Notes"}),"\n",(0,a.jsx)(e.p,{children:"Action planning from language has specific hardware requirements:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"CPU"}),": Multi-core processor for planning algorithms (4+ cores recommended)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory"}),": 4-8GB RAM for planning state spaces and search algorithms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Storage"}),": Fast storage for planning domain definitions and maps"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Network"}),": For cloud-based planning services (optional)"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Planning Performance Considerations"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Hierarchical planning: Plan high-level steps, then refine locally"}),"\n",(0,a.jsx)(e.li,{children:"Anytime planning: Provide best solution within time constraints"}),"\n",(0,a.jsx)(e.li,{children:"Reactive replanning: Update plans based on new information"}),"\n",(0,a.jsx)(e.li,{children:"Parallel planning: Consider multiple plan options simultaneously"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Resource Optimization"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Use simplified models for fast initial planning"}),"\n",(0,a.jsx)(e.li,{children:"Detailed planning only for critical steps"}),"\n",(0,a.jsx)(e.li,{children:"Caching of frequently used plans"}),"\n",(0,a.jsx)(e.li,{children:"Pre-computed navigation maps for common locations"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"5-simulation-path",children:"5. Simulation Path"}),"\n",(0,a.jsx)(e.p,{children:"To implement action planning in simulation:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Planning Simulation Setup"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Launch planning system with simulated environment\nros2 launch vla_robot_control action_planning_sim.launch.py\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Testing Framework"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Test action planning with various commands\nimport unittest\nfrom action_planner import ActionPlanner\n\nclass TestActionPlanner(unittest.TestCase):\n    def setUp(self):\n        self.planner = ActionPlanner(None)  # Pass None for testing\n\n    def test_navigation_planning(self):\n        command = {\n            'intent': 'navigation',\n            'action': {'action': 'move_to', 'target': 'kitchen'},\n            'entities': []\n        }\n        actions = self.planner.plan_action_from_language(command)\n        self.assertEqual(len(actions), 1)\n        self.assertEqual(actions[0].action_name, 'move_to')\n\n    def test_manipulation_planning(self):\n        command = {\n            'intent': 'manipulation',\n            'action': {'action': 'pick_up', 'object': 'red cup'},\n            'entities': [{'type': 'object', 'value': 'red cup'}]\n        }\n        actions = self.planner.plan_action_from_language(command)\n        # Should have navigation + manipulation actions\n        self.assertGreaterEqual(len(actions), 2)\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Integration Testing"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Test planning with simulated robot in Gazebo"}),"\n",(0,a.jsx)(e.li,{children:"Validate plan execution in safe simulation environment"}),"\n",(0,a.jsx)(e.li,{children:"Verify collision avoidance in planned paths"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"6-real-world-path",children:"6. Real-World Path"}),"\n",(0,a.jsx)(e.p,{children:"For real-world deployment:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Environment Mapping"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Create accurate maps of operational environment"}),"\n",(0,a.jsx)(e.li,{children:"Define semantic locations and object placement areas"}),"\n",(0,a.jsx)(e.li,{children:"Calibrate coordinate systems between language and physical space"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Safety Integration"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement safety checks for all planned actions"}),"\n",(0,a.jsx)(e.li,{children:"Add emergency stop capabilities"}),"\n",(0,a.jsx)(e.li,{children:"Verify action feasibility before execution"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Human-Robot Interaction"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement confirmation for complex actions"}),"\n",(0,a.jsx)(e.li,{children:"Add feedback during plan execution"}),"\n",(0,a.jsx)(e.li,{children:"Provide alternatives when plans fail"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Performance Optimization"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Optimize planning time for real-time response"}),"\n",(0,a.jsx)(e.li,{children:"Implement plan monitoring and adjustment"}),"\n",(0,a.jsx)(e.li,{children:"Add learning from successful plan executions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"7-spec-build-test-checklist",children:"7. Spec-Build-Test checklist"}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Action planning system implemented and integrated"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Language-to-action mapping working for common commands"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Task decomposition functioning correctly"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Navigation and manipulation planning integrated"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Plan validation and safety checks implemented"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance benchmarks established (2s planning time)"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Plan execution success rate >80% for test scenarios"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Error handling for unfeasible plans"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Integration testing with NLU and robot control systems"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Safety validation in both simulation and real environments"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"8-apa-citations",children:"8. APA citations"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Ghallab, M., Nau, D., & Traverso, P. (2016). ",(0,a.jsx)(e.em,{children:"Automated planning and acting"}),". Cambridge University Press."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Kaelbling, L. P., Littman, M. L., & Lozano-P\xe9rez, T. (1996). Planning and acting in partially observable stochastic domains. ",(0,a.jsx)(e.em,{children:"Artificial Intelligence"}),", 101(1-2), 99-134."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Fox, M., & Long, D. (2003). PDDL2. 1: An extension to PDDL for expressing temporal planning domains. ",(0,a.jsx)(e.em,{children:"Journal of Artificial Intelligence Research"}),", 20, 61-124."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Knepper, R. A., & Roy, N. (2009). Space-based decomposition planning for mobile manipulation. ",(0,a.jsx)(e.em,{children:"Proceedings of the 2009 IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 3755-3761."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Wolfe, J., & Lozano-P\xe9rez, T. (2010). Combined task and motion planning for mobile manipulation. ",(0,a.jsx)(e.em,{children:"Proceedings of the 2010 IEEE International Conference on Robotics and Automation"}),", 303-308."]}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>l});var t=i(6540);const a={},s=t.createContext(a);function o(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);